<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Advanced CSharp Learning Kit - Content</title>
    <!-- Global CSS -->
    <link rel="Stylesheet" type="text/css" media="all" href="../Style/master.css" />
    <link rel="Stylesheet" type="text/css" media="all" href="../Style/Menu.css" />
    <link rel="Stylesheet" type="text/css" media="all" href="../Style/topnav.css" />
    <link rel="Stylesheet" type="text/css" media="all" href="../Style/body.css" />
    <link rel="Stylesheet" type="text/css" media="all" href="../Style/tier2-page.css" />
    <link rel="Stylesheet" type="text/css" media="all" href="../Style/sticky-footer.css" />
    <link rel="Stylesheet" type="text/css" media="all" href="../Style/campaign.master.css" />
    <link rel="stylesheet" type="text/css" href="../Style/style1.css" />



    <style type="text/css">
        .ctl00_TopNavMenu_0 {
            background-color: white;
            visibility: hidden;
            display: none;
            position: absolute;
            left: 0px;
            top: 0px;
        }

        .ctl00_TopNavMenu_1 {
            text-decoration: none;
        }

        .ctl00_TopNavMenu_2 {
        }

        .horimenu ul {
            list-style: none;
        }

        .horimenu li {
            display: inline;
            padding: .2em 1em;
        }
    </style>
</head>
<body>
    <a name="top"></a>
    <div id="outerWrapper">
        <div id="wrapper" class="landingPage getStartedPage">
            <div id="whiteBkgdStrip">
            </div>
            <div class="header">
                <div class="mainHomepageTitle">

                </div>

                <div class="mainHomepageSubTitle" style="font-size:18px">
                    Learning Kit
                </div>
                <div class="AspNet-Menu-Horizontal" id="ctl00_TopNavMenu">

                </div>
            </div>
            <div class="contentWrapper">
                <div class="twoColWrapper_80_20">
                    <h1>Advanced C Sharp Programming</h1>

                    <!--One Unit-->

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_EnterpriseApp"></a>
                    <h2>Enterprise Application</h2>
                    <ul class="getStartedList">
                        <li>
                            <a name="LayeredArch"></a><strong>Layered Architecture</strong><br />
                            <p>
                                In the past, the companies that have tried to offer solutions for enabling an application to expose application integration information and functionality in a modular, scalable, and Internet-friendly way have encountered significant challenges. Main challenges are the following: <br />
                                <ul>
                                    <li>
                                        <b>Time to market  </b>The length of development time for getting an application to market may render the offering no longer viable
                                    </li>
                                    <li>
                                        <b>
                                            Scaling to the Web
                                        </b>
                                        Existing object models and component designs simply do not work over Internet protocols. Stateless application development that can be rerouted and served by any server is a new concept for many developers. Yet such a design pattern is vitally important to achieve global scalability
                                    </li>
                                    <li>
                                        <b>Lack of end-to-end development tools</b>
                                        Tool sets available today don't empower organizations with the flexibility necessary to stay ahead of their competitors. In the rapidly changing world of the Internet, organizations must exhibit the agility to integrate with new partners, using development tools that solve the challenges of today's heterogeneous computing environments
                                    </li>
                                </ul>
                                Designing an enterprise application involves numerous decisions — typically made by multiple people — about its logical and physical design, the technologies and infrastructure used to implement it. To help guide this process, it is necessary to have a conceptual model for the partitioning of functionality in the application. The following diagram — taken from the Microsoft guide Application Architecture for .NET: Designing Applications and Services — shows a typical conceptual view, which is appropriate to a wide range of specific application scenarios:

                            </p>

                            <p style="text-align:center">

                                <img src="Images/Layered_1.jpg" />

                            </p>
                            <p>
                                The components in this conceptual view include:
                                <ul>
                                    <li>
                                        <b>User Interface (UI) components</b>
                                        Most solutions provide some way for users to interact with the application. User interfaces are implemented using smart clients or Web pages to acquire, validate, render and format user data.
                                    </li>
                                    <li>
                                        <b>Business entity components</b>
                                        Most applications require data to be passed between components. For example, in the retail application a list of products must be passed from the data access logic components to the user interface components, so that the product list can be displayed to the users. The data is used to represent real world business entities, such as products or orders. The business entities that are used internally in the application are usually data structures provided by the platform, but they could also be implemented using custom object-oriented classes that represent the real world entities that applications have to deal with, such as a product or an order.
                                    </li>
                                    <li>
                                        <b>Business components</b>
                                        Virtually all applications and services require components that implement business rules and perform business tasks. Business components implement the business logic of the application.
                                    </li>
                                    <li>
                                        <b>Data access logic components</b>
                                        Almost all applications and services will need to access a data store at some point during a business process. Abstracting the data access logic in a separate layer centralizes data access functionality and makes it easier to configure and maintain
                                    </li>
                                </ul>
                                For more, please refer: http://msdn.microsoft.com/en-us/library/ms954601.aspx
                            </p>

                        </li>


                        <li>
                            <a name="AppDevCycle"></a><strong>Application Development Cycle</strong><br />
                            <p>
                                <h3>Use Case and Design Documents</h3>
                            </p>
                            <p>

                                <ul>
                                    <li>Requirements gathering and analysis – Business requirements are gathered from the clients, analyzed and the requirements document is created</li>
                                    <li>Design - Once the requirements are documented and signed off, the solutions for all use cases are designed and captured in a design document</li>
                                    <li>
                                        Responsibilities of a System Engineer in application development projects
                                        <ul>
                                            <li>Study the requirements document</li>
                                            <li>Study the design document</li>
                                            <li>Write the program</li>
                                            <li>Write the test cases</li>
                                            <li>Test the program and fix the bugs</li>
                                        </ul>
                                    </li>
                                </ul>
                            </p>
                            <p><h4>Read '901-System Requirements Specification', '902-Use Case Document' and '903-Detailed-Design Document' present in 'Reference Materials->Supplied Files' folder</h4></p>


                            <h3>Unit Testing</h3>
                            <p>
                                <ul>
                                    <li>While coding, it is important to test each unit of code for correctness</li>
                                    <li>The test cases ensure that the unit meet the given requirement</li>

                                </ul>
                            </p>
                            <p><h4>Analyze the test cases '907-UTP Registration sheet' present in 'Reference Materials->Supplied Files' folder</h4></p>
                        </li>
                    </ul>
                    <p><a href="#top">Top of page</a></p>

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_ExceptionHandling"></a>
                    <h2>Exception Handling</h2>    <!--Main Heading-->
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_IntroductionToExceptionHandling"></a><strong>Introduction to Exception Handling</strong><br />
                           
                            <br />
                            <p>When an error occurs, the program throws an exception. Exception is an object that contains information about the exception and its type.The runtime environment attempts to find the Exception Handler. If an Exception Handler is found, it is executed. Else, the runtime environment makes an exit from the program. Exception Handling constructs are helpful in separating the execution code from the error handler.</p> 
                            <p>Exceptions relating to fundamental errors are generated by CLR. These are often the conditions that are not as per the rules of the language or .NET execution environment. Exceptions can also be manually generated by writing code. This is used to indicate about some error condition to the caller of the method.</p>
                            <p>.NET exception handling is managed via try, catch, throw and finally. Enclose the code that you suspect of an exception being thrown, inside a try block. On an exception being thrown in try block, the control passes to the catch block. The catch block is specified for a type of exception that it would catch. The exception handler in the catch block attempts to recover from the error. If no recovery is possible, a gentle exit (i.e. a proper shutdown of application) from the program is provided. The piece of code that should be definitely executed irrespective of the error condition arising is placed in finally. throw statement is used explicitly to throw an exception.</p> 
                            <div class="codesnippet">
                                <div>
                                    <pre>    try
    {
        //Statement(s)
    }
    catch
    {
        //Statement(s)
    }
    finally
    {
        //Statement(s)
    }
</pre>
                                </div>
                            </div>
                            <br />
                            <div class="codesnippet">
                                <div>
                                    <pre>    class Program
    {
        static void Main(string[] args)
        {
              System.Console.WriteLine("Hello ");
              System.Console.WriteLine(args[0]); 
        }
    }
</pre>
                                </div>
                            </div>
                            <br />
                            <p>The above problem can be solved by checking the length of the array (string[] args) before trying to access its element. However, checking for all possible potential problems in this way is usually not possible. There will be too much of such error checking code and errors will have to be checked in the code itself.</p>
                            <br />
                            <div class="codesnippet">
                                <div>
                                    <pre>    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine("Hello ");
            try
            {
                System.Console.WriteLine(args[0]);
            }
            catch
            {
                System.Console.WriteLine("whoever you are");
            }
        }
    }
</pre>
                                </div>
                            </div>
                            <br />
                            <p>A try block is always followed by either catch block(s) or a finally block or both. finally block, if present, is always after all the catch blocks. The catch block handles or catches the exception. A catch block always monitors the preceding try block. The catch block is not executed if no exception is thrown. </p>
                            <p>The try-catch-finally construct can be written as:</p>
                            <ul>
                                <li>try {   } catch {  } finally {   }</li>
                                <li>try{    } catch {   }</li>
                                <li>try{    } finally {    }</li>
                            </ul>
                            Note that, in the construct (iii), the exception is not handled.<br />
                            <p>Multiple catch blocks can be associated to a single try block, each catch handling a different type of exception. However, after the execution of one catch block, others are ignored.</p>
                            <br />
                             <div class="codesnippet">
                                <div>
                                    <pre>    try
    {
        // statements
    }
    catch (ExceptionType1 et1)
    {
    // statements
    }
    /* Any number of catch block can be used */
    catch (ExceptionType2 et2)
    {
    //statements
    }
    /* This gets executed irrespective of occurrence of exception */
    finally
    {
    // statements
    }
</pre>
                                </div>
                            </div>
                            <br />
                            <p>The piece of code that should be definitely executed irrespective of the error condition arising is placed in finally. It defines a block of code that always executes, regardless of whether an exception was caught or not. When an exception is raised, finally executes the code present in it before the control moves out of the method. </p>
                            <p>In the normal execution it is executed after the try block. When an exception occurs, it is executed after the handler if any or before propagation to outer try block or runtime, as the case may be.</p>
                            <p>The circumstances that prevent execution of the code in a finally blocks are:</p>
                            <ul>
                                <li>The death of a Thread</li>
                                <li>Using of the System.Environment.Exit() method.</li>
                            </ul>
                            <p>An exception in the finally block, will be propagated to outer try block or runtime, and the remaining statements in the finally block will not be executed.</p>
                            

                        </li>

                        <li>
                            <a name="SM_SystemExceptions"></a><strong>System Exceptions</strong><br/>
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="http://digitaltutor/#/video/6/11/0">Video</a></li>&nbsp;&nbsp;&nbsp;&nbsp;
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo1_SystemDefinedExceptions">Demo</a></li>
                            </ul>
                            <p style="text-align:center">
                                <img src="Images\SM_SystemExceptions.jpg" />
                            </p> 
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    try
    {
	    int num1, num2 = 5, num3 = 0;
	    num1 = num2 / num3;
	    int[] myArray = new int[20];
	    myArray[20] = 1000;
    }
    catch (DivideByZeroException exDBZ)
    {
             // statements
    }
    catch (IndexOutOfRangeException exIOR)
    {
	    //statements
    }
    finally
    {
	    // statements  
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>When the execution reaches num1 = num2/num3, as the value of num3 is zero, CLR throws DivideByZeroException. Now the appropriate catch block has to be executed. CLR looks for appropriate catch blocks in the order they are written. The first catch block is the appropriate as it is written to handle DivideByZeroException. This first catch block is executed. Only one catch block will be executed. Then, the execution flows to finally block</p>
                            <p>Now the execution moves on to the statement that follows finally block</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    try
    {
	    int num1, num2 = 5, num3 = 0;
	    num1 = num2 / num3;
	    int[] myArray = new int[20];
	try
        {
	        int num1, num2 = 5, num3 = 1;
	        num1 = num2 / num3;
	        int[] myArray = new int[20];
	        myArray[20] = 1000;
        }
        catch (DivideByZeroException exDBZ)
        {
                 // statements
        }
        catch (IndexOutOfRangeException exIOR)
        {
	        //statements
        }
        finally
        {
	        // statements  
        }
	    myArray[20] = 1000;
    }
    catch (DivideByZeroException exDBZ)
    {
             // statements
    }
    catch (IndexOutOfRangeException exIOR)
    {
	    //statements
    }
    finally
    {
	    // statements  
    }

</pre>
                                    </div>
                                </div>
                            </p>
                            <p>When the execution reaches myArray[20] = 1000, CLR throws IndexOutOfRangeException. This happens as the array ‘myArray’ can be accessed from myArray[0] to myArray[19]. Now the appropriate catch block has to be executed. CLR looks for appropriate catch blocks in the order they are written. The first catch block is not appropriate as it is written to handle DivideByZeroException. Now the second catch block is taken for a match. The second catch block matches as it is written to handle IndexOutOfRangeException. Now the second catch block is executed. Then, the execution flows to finally block. Now the execution moves on to the statement that follows finally block</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    try
    {
    // statements
    }
    catch (Exception ex)
    {
    // statements
    }
    catch (DivideByZeroException exDBZ)
    {
    //statements
    }
    finally
    {
    // statements
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>During the occurrence of the exception in the try block, catch block is chosen in the way they are written. In the above example, writing the catch block to handle Exception type as a first catch block makes the following catch block unreachable code. For this reason, the compiler does not compile this code and produces compiler error. In the case of multiple catch blocks, always place the catch block that is written to handle the parent type exception (or ancestor type exception in case of multilevel inheritance) at the last among the exception types used.</p>
                        </li>
                        
                        <li>
                            <a name="SM_NestedExceptions"></a><strong>Nested Exceptions</strong><br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo1_NestedExceptions">Demo</a></li>
                            </ul>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    /* statements */
    try
    {
        /* statements  */
        try
        { /* statements */ }
        catch (ExceptionType1 et1)
        { /* statements */ }
        catch (ExceptionType2 et2)
        { /* statements */ }
        finally
        { /* statements */ }
        /* statements */
    }
    catch (ExceptionType3 et3)
    { /* statements */ }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>When an exception is thrown by the CLR for the inner try block and there is no matching inner catch blocks, the CLR will look for the appropriate outer catch block</p>
                           
                        </li>

                        <li>
                            <a name="SM_UserDefinedExceptions"></a><strong>User-Defined Exceptions</strong><br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo1_UserDefinedExceptions">Demo</a></li>
                                <li class="last"><a href="../Exercises/AdvancedCSharpExercises.htm#DE_ExceptionHandling">Exercise</a></li>
                                <li class="last"><a href="../Assignments/AdvancedCSharpAssignments.htm#A_NestedExceptions">Assignment</a></li>
                            </ul>

                            <p>Customized exception can be developed based on requirements. When a Age property is assigned with a wrong value (let say -20), throwing a exception like InvalidAgeValueException would be better approach. Build the custom exception class by inheriting Exception classTo raise the custom exception at appropriate moment, use throw.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class InvalidAgeException : Exception 
    {
       public InvalidAgeException() : base() {}
       public InvalidAgeException(string msg) : base(msg) {}
    }
    class Person 
    {
       private int age;
       public int Age
       {
           set
           {
               if (value >= 19 && value <= 60)
                   age = value;
               else
               {
                   InvalidAgeException expObj = new InvalidAgeException(“Age should be 19-60");
                   throw expObj;
               }
           }
       }
    }
    class Program
    {
        public static void Main(string[] args)
        {
            Person personObj = new Person();
            Console.Write("Enter the age : ");
            try
            {
                string ageInput = Console.ReadLine();
                /* convert the string value into int value */
                personObj.Age = int.Parse(ageInput);
                Console.WriteLine("Valid Input");
            }
            catch (InvalidAgeException expObj)
            {
                Console.WriteLine(expObj.Message);
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>When an exception is thrown by the CLR for the inner try block and there is no matching inner catch blocks, the CLR will look for the appropriate outer catch block</p>

                        </li>

                        <li>
                            <a name="SM_ExceptionBestPractices"></a><strong>Exception-Best Practices</strong><br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Quiz/Exceptions.htm">Quiz</a></li>
                            </ul>
                            <ul>
                                <li>Do Not Use Exceptions to Control Application Flow because Throwing exceptions is expensive.</li>
                                <li>Use Validation Code to Reduce Unnecessary Exceptions : If you know that a specific avoidable condition can happen, proactively write code to avoid it. For example, adding validation checks such as checking for null before using an item from the cache can significantly increase performance by avoiding exceptions.</li>
                                <li>Use the finally Block to Ensure Resources Are Released : For both correctness and performance reasons, it is good practice to release all expensive resources in a  finally block.</li>
                                <li>Do Not Catch Exceptions That You Cannot Handle : Do not arbitrarily catch exceptions unless you can add some value. You should not catch generic exceptions in your code as follows.<br />catch (Exception e){....}<br />This results in catching all exceptions.</li>
                                <li>Be Aware That Rethrowing Is Expensive : The cost of rethrowing an existing exception is approximately the same as throwing a new exception.</li>
                            </ul>

                        </li>

                    </ul> <!--Sub Heading-->
                    <p><a href="#top">Top of page</a></p>
                                                                               
                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_Generics"></a>
                    <h2>Generics</h2>    <!--Main Heading-->
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_NeedForGenerics"></a><strong>Need For Generics</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_NeedForGenerics">Demo</a></li>
                            </ul>

                            <p>Let us assume that we wish to write a class for implementing the stack data structure.We want the stack class to work with any type, hence, let us write stack class for storing items of System.Object type. Objects of any type can be stored by automatic conversion to System.Object</p>                         
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Stack
    {
        int size;
        int stackPointer = 0;
        object[] items;
        public Stack(int size)
        {
            this.size = size;
            items = new object[size];
        }
        public void Push(object item)
        {
            if (stackPointer >= size)
                throw new StackOverflowException();
            items[stackPointer] = item;
            stackPointer++;
        }
        public object Pop()
        {
            stackPointer--;
            if (stackPointer >= 0)
            {
                return items[stackPointer];
            }
            else
            {
                stackPointer = 0;
                throw new   	InvalidOperationException(“Empty Stack");
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>When using value types, you have to box them in order to push and store them, and unbox the value types when popping them off the stack.  Boxing and unboxing incurs a significant performance penalty</p>
                            <p>Even when using reference types you have to cast from an Object to the actual type you interact with. There is still a performance penalty because we incur the casting cost. </p>
                            <p>A more severe problem is that we lose compile time type safety.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    Stack stack = new Stack();
    stack.Push(1);
    //This compiles, but is not type safe, and will throw an exception: 
    string number = (string)stack.Pop();
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>It is safe to assume that a given stack instance will store types of only a single type.</p>
                            <p>To avoid problems associated with an Object- based stack, it is desirable to write a different stack class for each type that wish to use stack for.</p>
                            <p>Depending on need a particular class will be instantiated</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class IntStack
    {
        int[] items;
        public void Push(int item){ }
        public int Pop(){ }
    } 
    public class StringStack
    {
        string[] items;
        public void Push(string item){ }
        public string Pop(){ }
    }

</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The stack classes for Integer and String are given above. We need to write similar classes for each type. The classes above can be used as follows:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    IntStack stack = new IntStack();
    stack.Push(1);
    int number = stack.Pop();
    StringStack stack = new StringStack();
    stack.Push("1");
    string number = stack.Pop();
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The previous solution does solve both- performance and type-safety problems. But it results into another serious problem- we need to write a stack class for each type. Writing type-specific data structures are a tedious, repetitive, and error-prone task. We wish we could write a data structure once for all types but use it in a type-specific manner. For example, the stack class can be written once for all types but an instance of this class can work with only one type. The type that it is bound to can be provided at the time of instantiation. Generics in C# provides us this desired flexibility</p>
                        </li>

                        <li>
                            <a name="SM_GenericClassInterfaceMethod"></a><strong>Writing Generic Class, Interface and Method</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="http://digitaltutor/#/video/6/9/0" target="_blank">Video</a></li>
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_WorkingWithGenericClass">Demo</a></li>
                                <li class="last"><a href="../Exercises/AdvancedCSharpExercises.htm#E_WorkingWithGenericClass">Exercise</a></li>
                            </ul>

                            <p>Generics allow you to define type-safe classes without compromising performance and productivity. We write the class only once as a generic class, while at the same time we can declare and use it with any type. To do that, we use the < and > brackets, enclosing generic type parameters. The formal generic parameters can be used in the class body. Even the methods in the class can be declared using the formal generic parameters. Following is how a generic Stack class can be defined and used</p>
                            <p>Creating Generic Class and Methods:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Stack&lt;T&gt;
    {
        readonly int size;
        int stackPointer = 0;
        T[] items;
        public Stack(int size)
        {
            this.size = size;
            items = new T[size];
        }
        public void Push(T item)
        {
            if (stackPointer >= size)
                throw new StackOverflowException();
            items[stackPointer] = item;
            stackPointer++;
        }
        public T Pop()
        {
            stackPointer--;
            if (stackPointer >= 0)
            {
                return items[stackPointer];
            }
            else
            {
                stackPointer = 0;
                throw new 
                InvalidOperationException("Empty Stack");
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>Using Generic Class and Method:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    Stack&lt;int&gt; stack = new Stack&lt;int&gt;();
    stack.Push(1);
    int number = stack.Pop();
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>Generic type parameter can be used as </p>
                            <ul>
                                <li>Member type</li>
                                <li>Local variable type</li>
                                <li>Parameter type</li>
                                <li>Return type</li>
                            </ul>
                            <p>More than one Generic parameter can also to used in a class/method. The name of a Generic parameter can be any identifier but is typically named as T, U, V..</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class KeyValuePair&lt;T, U&gt;
    {
        T key;
        U value;
        public KeyValuePair(T key, U value)
        {
            this.key = key;
            this.value = value;
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>




                        </li>


                    </ul> <!--Sub Heading-->
                    <p><a href="#top">Top of page</a></p>

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_NonGenericCollections"></a>
                    <h2>Non-Generic Collections</h2>    <!--Main Heading-->
                    <br />
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_IntroductiontoNCollections"></a><strong>Introduction to Collections</strong><br />
                            <br />
                            <p>Collections are data structures which help us in constructing and manipulating a group of objects.C# contains many non-generic collections under System.Collections namespace. Most of these collections are based on System.Object type, and involve issues related to boxing, unboxing and type-casting.</p>
                            <p>C# also contains many Generic collections under System.Collections.Generic namespace. It is advisable to use Generic collections to avoid issues related to boxing, unboxing and type-casting.</p>
                            <p>Collections have the advantage of dynamic memory allocation. This means that memory need not be allocated at compile; it is allocated at runtime</p>
                            <p>Few of the collection classes are listed below:</p>
                            <table class="content-table">
                                <tr>
                                    <th>Usage</th>
                                    <th>Generic Collection</th>
                                    <th>Non-Generic Collection</th>
                                </tr>
                                <tr>
                                    <td>List of Single Values</td>
                                    <td>List&lt;T&gt;</td>
                                    <td>ArrayList</td>
                                </tr>
                                <tr>
                                    <td>List of Sorted Key-Value pairs</td>
                                    <td>SortedList&lt;K,T&gt;</td>
                                    <td>SortedList</td>
                                </tr>
                                <tr>
                                    <td>List of Key-Value Pairs</td>
                                    <td>Dictionary&lt;K,T&gt;</td>
                                    <td>Hashtable</td>
                                </tr>
                            </table><br />
                        </li>


                        <li>
                            <a name="SM_ArrayList"></a><strong>ArrayList</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="http://digitaltutor/#/video/6/10/1" target="_blank">Video</a></li>
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_ArrayList">Demo</a></li>
                            </ul>

                            <p>System.Collections.ArrayList is a list, size of which changes dynamically</p>
                            <ul>
                                <li>No need to define the size at the time of instantiation</li>
                                <li>The capacity of ArrayList would change on its own changes, if required, as elements are added.</li>
                            </ul>
                            <p>Items can be removed from anywhere, and indexes adjusted accordingly. The items in the ArrayList are retrieved through a zero-based index. ArrayList accepts ‘null’ as a valid value and allows users to store duplicate elements. Provides methods to add or remove a range of elements</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Program  
    {
        public static void Main()  
        {
            ArrayList newList= new ArrayList();
            newList.Add( "Alice");
            newList.Add( "Wonderland");
            newList.Add( "Dreamland");
            Console.WriteLine("Count: " +newList.Count);
            Console.WriteLine("Capacity: "+newList.Capacity);
            Console.WriteLine( "  - ELEMENTS -" );
            for (int index = 0;index &lt; newList.Count;index++)
            {
                    Console.WriteLine(newList[index]);
            }
            newList.RemoveAt(1);
            Console.WriteLine("Count:{0}", newList.Count);
            Console.WriteLine("Capacity:{0}", newList.Capacity);
            Console.WriteLine("  - ELEMENTS -");
            for (int index = 0; index < newList.Count; index++)
            {
                Console.WriteLine(newList[index]);
            }    
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <h4>Using foreach:</h4>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Program
    {
        public static void Main()
        {
            int[] arrNum = { 10, 20, 30, 40 };
            foreach (int number in arrNum)
            {
                Console.WriteLine(number);
            }
       
            ArrayList myList = new ArrayList();
            myList.Add("Alice");
            myList.Add(25);
            foreach (object objList in myList)
            {
		    Console.WriteLine(objList);
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>




                        </li>

                        <li>
                            <a name="SM_SortedList"></a><strong>Sorted List</strong><br />
                            <br />
                            <p>
                                SortedList classes allow storing elements in the collection as a key-value pair that always remain sorted based on the keys. An item can be accessed by the key as well as the index.
                                A key cannot be duplicate or null, whereas a value can be duplicate or null.
                                Whenever an item is added or deleted from a SortedList, the indices of elements are adjusted to keep the list in the sorted order. Hence such operations are slower in this collection
                                In System.Collections.SortedList, keys and values can be of any type and are stored in System.Object form
                            </p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Program  
    {
        public static void Main()  
        {
            SortedList newList = new SortedList();
            newList.Add("First", "Alice");
            newList.Add("Second", "Wonderland");
            newList.Add("Third", "Dreamland");
            Console.WriteLine("Count: "+ newList.Count );   
            Console.WriteLine("Capacity: "+newList.Capacity );
            PrintElements(newList );
        }
        public static void PrintElements(SortedList myList)
        {
            Console.WriteLine( "\t-KEY-\t-VALUE BY KEY-\t-VALUE BY INDEX- " );
            for ( int index = 0; index &lt; myList.Count; index++ )  
            {
                Console.WriteLine( "\t{0}:\t{1}:\t{2}", 
	        myList.GetKey(index), myList[myList.GetKey(index)], myList.GetByIndex(index));
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>


                        </li>

                        <li>
                            <a name="SM_HashTable"></a><strong>Hash Table</strong><br />
                            <br />
                            <p>Hashtable is collection of key and value pairs. In System.Collections.Hashtable, keys and values can be of any type and are stored in System.Object form.</p>
                            <p>Hashtable differs from SortedList in following major respects:</p>
                            <ul>
                                <li>The items are not sorted according to the key.</li>
                                <li>The retrieval of keys or values cannot be based on index. This means that a value can be accessed only based on key.</li>
                            </ul>
                            <p>If it is not required that data be kept sorted according to the key, it is advisable to use HashTable over SortedList</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Program
    {
        public static void Main()
        {
            Hashtable newList = new Hashtable();
            newList.Add(101, "Alice");
            newList.Add("Wonderland", 102);
            Console.WriteLine(newList[101]);
            Console.WriteLine(newList["Wonderland"]);
            Console.WriteLine(newList[104]);
        }       
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>foreach can be used for HashTable as follows:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Program
    {
        public static void Main()
        {
            Hashtable newList = new Hashtable();
            newList.Add("First", "Alice");
            newList.Add("Second", "Wonderland");
            newList.Add("Third", "Dreamland");
            PrintElements(newList);
        }
        public static void PrintElements(Hashtable myList)
        {
            Console.WriteLine("\t-KEY-\t-VALUE- ");
            foreach(DictionaryEntry de in myList)
            {
                Console.WriteLine("\t{0}:\t{1}", de.Key, de.Value);
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                        </li>

                        <!--<li>
                                    <a name="SM_EnumerableClass"></a><strong>Enumerable Class</strong><br />
                                    <br />
                                    <p>Microsoft has given quiet a number of collection classes like Stack, Queue, List, Dictionary, SortedList, etc. In order to iterate (traverse) through the elements of these collections, we can use a foreach loop. “foreach” works on all these collections and even more. But, the question to be asked is “How it works?” The answer to this question is through “Enumeration”. </p>
                                    <p>The C# collection framework has several important interfaces – one for the generic collection and the other for the non-generic.</p>
                                    <p>Generic Collection interfaces for enumerating through the collection classes are - IEnumerable&lt; T &gt; and IEnumerator&lt; T &gt;.</p>
                                    <p>Non-Generic Collection interfaces for enumerating through the collection classes are - IEnumerable and IEnumerator.</p>

                                    <h4>The IEnumerable&lt; T &gt; interface:</t></h4>
                                    <p>This interface has only one important method called “GetEnumerator()”. The signature of the method is as follows:</p>
                                    <p>
                                        <div class="codesnippet">
                                            <div>
                                                <pre>    IEnumerator&lt;T&gt; GetEnumerator();
        </t></pre>
                                            </div>
                                        </div>
                                    </p>
                                    <p>We can use this method to get an enumerator to enumerate a collection. In other words, the method GetEnumerator() returns a handler (or pointer) to the collection using which we can traverse through all the elements of the collection on which this method was called. </p>
                                    <p style="text-align:center">
                                        <img src="Images/SM_EnumerableClass.jpg" />
                                    </p>
                                    <p>The IEnumerator interface contains a Current property, and MoveNext() and Reset() methods.</p>
                                    <p><strong>Property of IEnumerator:</strong></p>
                                    <table class="content-table">
                                        <tr>
                                            <th>Name</th>
                                            <th>Description</th>
                                        </tr>
                                        <tr>
                                            <td>Current</td>
                                            <td>Gets the current element in the collection.</td>
                                        </tr>
                                    </table>
                                    <p><strong>Methods of IEnumerator:</strong></p>
                                    <table class="content-table">
                                        <tr>
                                            <th>Name</th>
                                            <th>Description</th>
                                        </tr>
                                        <tr>
                                            <td>MoveNext()</td>
                                            <td>Advances the enumerator to the next element of the collection</td>
                                        </tr>
                                        <tr>
                                            <td>Reset()</td>
                                            <td>Sets the enumerator to its initial position, which is before the first element in the collection</td>
                                        </tr>
                                    </table>
                                    <p>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</p>
                                    <p>The Reset() method does not need to be fully implemented.</p>
                                    <p>Initially, the enumerator is positioned before the first element in the collection. You must call the MoveNext() method to advance the enumerator to the first element of the collection before reading the value of Current; otherwise, Current is undefined.Current returns the same object until either MoveNext() or Reset() is called. MoveNext() sets Current to the next element.</p>
                                    <p>If MoveNext() passes the end of the collection, the enumerator is positioned after the last element in the collection and MoveNext() returns false. When the enumerator is at this position, subsequent calls to MoveNext() also return false. If the last call to MoveNext() returned false, calling Current throws an exception. </p>
                                    <h3>Example:</h3>
                                    <p>
                                        <div class="codesnippet">
                                            <div>
                                                <pre>    class Program
            {
                static void Main(string[] args)
                {
                    ArrayList people = new ArrayList();
                    people.Add("John");
                    people.Add("Carey");
                    people.Add("Wilson");
                    people.Add("Bruce");
                    // Method - 1: Using "foreach" loop
                    foreach (string person in people)
                    {
                        Console.WriteLine(person);
                    }
                    // Method - 2: Using "IEnumerator" interface
                    IEnumerator iterator = people.GetEnumerator();
                    while (iterator.MoveNext())
                    {
                        Console.WriteLine(iterator.Current);
                    }
                }
            }
        </pre>
                                            </div>
                                        </div>
                                    </p>
                                    <p>Both the methods we used in the above code snippet will produce the same output.
        Consider another example given below. Assume there is a Trainee class with Name and CGPA as their data members (consider both the members as public for this demonstration purpose). Another class Batch which comprise of a set of trainee objects (like an array) to initialize them. We would like to use an iteration mechanism for the Batch class to iterate through each and every trainee object to display the trainee details.
        </p>
                                    <p>
                                        <div class="codesnippet">
                                            <div>
                                                <pre>    namespace IteratorDemo
            {
                public class Trainee
                {
                    public string Name;
                    public float CGPA;
                    public Trainee(string nameValue, float CGPAValue)
                    {
                        Name = nameValue;
                        CGPA = CGPAValue;
                    }
                }
                public class Batch
                {
                    private Trainee[] traineeArr;
                    public Batch()
                    {
                        traineeArr = new Trainee[3];
                        traineeArr[0] = new Trainee("John", 4.5f);
                        traineeArr[1] = new Trainee("Dennis", 4.8f);
                        traineeArr[2] = new Trainee("Carol", 4.7f);
                    }
                }
            }
        </pre>
                                            </div>
                                        </div>
                                    </p>
                                    <p>The code for the starter class is given below:</p>
                                    <p>
                                        <div class="codesnippet">
                                            <div>
                                                <pre>    class Program
            {
                static void Main(string[] args)
                {
                    Batch bObj=new Batch();
                    // Traverse through each of the items
                    foreach(Trainee tObj in bObj)
                    {
                        Console.WriteLine(tObj.Name+" "+tObj.CGPA);
                    }
                }
            }
        </pre>
                                            </div>
                                        </div>
                                    </p>
                                    <p>The above code will throw the following error: “foreach statement cannot operate on variables of type ‘Batch’ because it does not contain a public definition for GetEnumerator()”</p>
                                    <p>This is because the array of Trainees is a custom collection. In order to enumerate through a custom collection, that particular class should implement IEnumberable interface.</p>
                                    <p>The Batch class when implements the IEnumerable interface of the System.Collections namespace as shown below, the Batch class knows how to iterate through a set of Trainee objects.</p>
                                    <p>
                                        <div class="codesnippet">
                                            <div>
                                                <pre>    public class Batch:IEnumerable
            {
                private Trainee[] traineeArr;
                public Batch()
                {
                    traineeArr=new Trainee[3];
                    traineeArr[0]=new Trainee("John",4.5f);
                    traineeArr[0]=new Trainee("Dennis",4.8f);
                    traineeArr[0]=new Trainee("Carol",4.7f);
                }
                #region IEnumerable Members
                public IEnumerator GetEnumerator()
                {
                    return traineeArr.GetEnumerator();
                }
                #endregion
            }
        </pre>
                                            </div>
                                        </div>
                                    </p>
                                </li>-->
                    </ul> <!--Sub Heading-->
                    <p><a href="#top">Top of page</a></p>

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_Collections"></a>
                    <h2>Generic Collections</h2>    <!--Main Heading-->
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_IntroductiontoCollections"></a><strong>Introduction to Collections</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="http://digitaltutor/#/video/6/10/2" target="_blank">Video</a></li>
                            </ul>

                            <p>Collections are data structures which help us in constructing and manipulating a group of objects.C# contains many non-generic collections under System.Collections namespace. Most of these collections are based on System.Object type, and involve issues related to boxing, unboxing and type-casting.</p>
                            <p>C# also contains many Generic collections under System.Collections.Generic namespace. It is advisable to use Generic collections to avoid issues related to boxing, unboxing and type-casting.</p>
                            <p>Collections have the advantage of dynamic memory allocation. This means that memory need not be allocated at compile; it is allocated at runtime</p>
                            <p>Few of the collection classes are listed below:</p>
                            <table class="content-table">
                                <tr>
                                    <th>Usage</th>
                                    <th>Generic Collection</th>
                                    <th>Non-Generic Collection</th>
                                </tr>
                                <tr>
                                    <td>List of Single Values</td>
                                    <td>List&lt;T&gt;</td>
                                    <td>ArrayList</td>
                                </tr>
                                <tr>
                                    <td>List of Sorted Key-Value pairs</td>
                                    <td>SortedList&lt;K,T&gt;</td>
                                    <td>SortedList</td>
                                </tr>
                                <tr>
                                    <td>List of Key-Value Pairs</td>
                                    <td>Dictionary&lt;K,T&gt;</td>
                                    <td>Hashtable</td>
                                </tr>
                            </table><br />
                            <p>Generic Collections are preferred over Non-Generic Collections unless data of various types needs to be stored in the same collection.</p>
                            <p>In case of SortedList, the key should contain data of same type even though it is a non-generic collection. A runtime error is thrown as data of different types cannot be sorted.</p>
                            <p>Dictionary&lt;K,T&gt; is preferred over SortedList&lt;K,T&gt; as data need not be kept in a sorted order in case of Dictionary&lt;K,T&gt;</p>
                        </li>
                        
                        <li>
                            <a name="SM_List"></a><strong>List&lt;T&gt;</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                               
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo1_GenericList">Demo</a></li>
                                <li class="last"><a href="../Assignments/AdvancedCSharpAssignments.htm#A_GenericList">Assignment</a></li>
                            </ul>

                            <p>System.Collections.Generic.List is a list, size of which changes dynamically</p>
                            <ul>
                                <li>No need to define the size at the time of instantiation</li>
                                <li>The capacity of List would change on its own changes, if required, as elements are added.</li>
                            </ul>
                            <p>Items can be removed from anywhere, and indexes adjusted accordingly. The items in the List are retrieved through a zero-based index. List doesn’t accepts ‘null’ as a valid value. It allows users to store duplicate elements. Provides methods to add or remove a range of elements</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Program  
    {
       public static void Main()  
       {
          List&lt;int&gt; newList= new List&lt;int&gt;();
          int sum = 0;
          newList.Add(1);
          newList.Add(2);
          //newList.Add("Three");
          Console.WriteLine( "Count:{0}", newList.Count );
          Console.WriteLine( "Capacity:{0}", newList.Capacity );
          for (int index = 0; index &lt; newList.Count; index++)
          {
              sum = sum + newList[index];
          }
          Console.WriteLine("Sum: " + sum);
       }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p></p>



                        </li>

                        <li>
                            <a name="SM_GenericSortedList"></a><strong>SortedList&lt;K,T&gt;</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="http://digitaltutor/#/video/6/10/3" target="_blank">Video</a></li>
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo1_GenericSortedList">Demo</a></li>
                                <li class="last"><a href="../Exercises/AdvancedCSharpExercises.htm#E_GenericSortedList">Exercise</a></li>
                            </ul>

                            <p>SortedList classes allow storing elements in the collection as a key-value pair that always remain sorted based on the keys. An item can be accessed by the key as well as the index
A key cannot be duplicate, whereas a value can be.
                            </p>
                            <p>Whenever an item is added or deleted from a SortedList, the indices of elements are adjusted to keep the list in the sorted order. Hence such operations are slower in this collection</p>
                            <p>In System.Collections.Generic.SortedList&lt;K,T&gt;, key is of generic type K and value is of generic type T.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Program  
    {
        public static void Main()  
        {
            SortedList&lt;int, string&gt; newList = new SortedList&lt;int, string&gt;();
            newList.Add(101, "Alice");
            newList.Add(102, "Wonderland");
            newList.Add(103, "Dreamland");
            Console.WriteLine("Count: "+ newList.Count );   
            Console.WriteLine("Capacity: "+newList.Capacity);
            PrintElements(newList);
        }
        public static void PrintElements(SortedList&lt;int, string&gt; myList)
        {
            Console.WriteLine( "\t-KEY-\t-VALUE BY KEY-\t-VALUE BY INDEX- " );
            for ( int index = 0; index &lt; myList.Count; index++ )  
            {
                Console.WriteLine( "\t{0}:\t{1}:\t{2}", myList.Keys[index],myList[myList.Keys[index]],myList.Values[index]);
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                        </li>

                        <li>
                            <a name="SM_Dictionary"></a><strong>Dictionary&lt;K,T&gt;</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                              
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo1_Dictionary">Demo</a></li>
                                <li class="last"><a href="../Exercises/AdvancedCSharpExercises.htm#E_GenericCollections">Exercise</a></li>
                                <li class="last"><a href="../Assignments/AdvancedCSharpAssignments.htm#AA_WorkingWithGenericCollections">Assignment</a></li>
                                <li class="last"><a href="../Quiz/Collections.htm">Quiz</a></li>
                            </ul>

                            <p>Dictionary differs from SortedList in following major respects:</p>
                            <ul>
                                <li>The items are not sorted according to the key.</li>
                                <li>The retrieval of keys or values cannot be based on index. This means that a value can be accessed only based on key</li>
                            </ul>
                            <p>If it is not required that data be kept sorted according to the key, it is advisable to use Dictionary&lt;K,T&gt; over SortedList&lt;K,T&gt;.</p>
                            <p>In System.Collections.Generic.Dictionary&lt;T,U&gt;, key is of generic type T and value is of generic type U.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    Dictionary&lt;int, string&gt; newList = new Dictionary&lt;int, string&gt;();
    newList.Add(101, "Alice");
    // newList.Add("Wonderland", 102);
    newList.Add(103, "Dreamland");
    Console.WriteLine(newList[101]);
    //Console.WriteLine(newList["Wonderland"]);
    Console.WriteLine(newList[103]); 

</pre>
                                    </div>
                                </div>
                            </p>
                            <p>foreach can be used for Dictionary&lt;K,T&gt; as follows:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Program
    {
        public static void Main()
        {
            Dictionary&lt;string, string&gt; newList = new Dictionary&lt;string, string&gt;();
            newList.Add("First", "Alice");
            newList.Add("Second", "Wonderland");
            newList.Add("Third", "Dreamland");
            PrintElements(newList);
        }
        public static void PrintElements(Dictionary&lt;string, string&gt; myList)
        {
            Console.WriteLine("\t-KEY-\t-VALUE- ");
            foreach(KeyValuePair&lt;string, string&gt; kvp in myList)
            {
                Console.WriteLine("\t{0}:\t{1}", kvp.Key, kvp.Value);
            }
        }
    }</pre>
                                    </div>
                                </div>
                            </p>



                        </li>
                        
                        <!--<li>
                            <a name="SM_EnumerableClass"></a><strong>Enumerable Class</strong><br />
                            <br />
                            <p>Microsoft has given quiet a number of collection classes like Stack, Queue, List, Dictionary, SortedList, etc. In order to iterate (traverse) through the elements of these collections, we can use a foreach loop. “foreach” works on all these collections and even more. But, the question to be asked is “How it works?” The answer to this question is through “Enumeration”. </p>
                            <p>The C# collection framework has several important interfaces – one for the generic collection and the other for the non-generic.</p>
                            <p>Generic Collection interfaces for enumerating through the collection classes are - IEnumerable&lt; T &gt; and IEnumerator&lt; T &gt;.</p>
                            <p>Non-Generic Collection interfaces for enumerating through the collection classes are - IEnumerable and IEnumerator.</p>

                            <h4>The IEnumerable&lt; T &gt; interface:</t></h4>
                            <p>This interface has only one important method called “GetEnumerator()”. The signature of the method is as follows:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    IEnumerator&lt;T&gt; GetEnumerator();
</t></pre>
                                    </div>
                                </div>
                            </p>
                            <p>We can use this method to get an enumerator to enumerate a collection. In other words, the method GetEnumerator() returns a handler (or pointer) to the collection using which we can traverse through all the elements of the collection on which this method was called. </p>
                            <p style="text-align:center">
                                <img src="Images/SM_EnumerableClass.jpg" />
                            </p>
                            <p>The IEnumerator interface contains a Current property, and MoveNext() and Reset() methods.</p>
                            <p><strong>Property of IEnumerator:</strong></p>
                            <table class="content-table">
                                <tr>
                                    <th>Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <td>Current</td>
                                    <td>Gets the current element in the collection.</td>
                                </tr>
                            </table>
                            <p><strong>Methods of IEnumerator:</strong></p>
                            <table class="content-table">
                                <tr>
                                    <th>Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <td>MoveNext()</td>
                                    <td>Advances the enumerator to the next element of the collection</td>
                                </tr>
                                <tr>
                                    <td>Reset()</td>
                                    <td>Sets the enumerator to its initial position, which is before the first element in the collection</td>
                                </tr>
                            </table>
                            <p>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</p>
                            <p>The Reset() method does not need to be fully implemented.</p>
                            <p>Initially, the enumerator is positioned before the first element in the collection. You must call the MoveNext() method to advance the enumerator to the first element of the collection before reading the value of Current; otherwise, Current is undefined.Current returns the same object until either MoveNext() or Reset() is called. MoveNext() sets Current to the next element.</p>
                            <p>If MoveNext() passes the end of the collection, the enumerator is positioned after the last element in the collection and MoveNext() returns false. When the enumerator is at this position, subsequent calls to MoveNext() also return false. If the last call to MoveNext() returned false, calling Current throws an exception. </p>
                            <h3>Example:</h3>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Program
    {
        static void Main(string[] args)
        {
            ArrayList people = new ArrayList();
            people.Add("John");
            people.Add("Carey");
            people.Add("Wilson");
            people.Add("Bruce");
            // Method - 1: Using "foreach" loop
            foreach (string person in people)
            {
                Console.WriteLine(person);
            }
            // Method - 2: Using "IEnumerator" interface
            IEnumerator iterator = people.GetEnumerator();
            while (iterator.MoveNext())
            {
                Console.WriteLine(iterator.Current);
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>Both the methods we used in the above code snippet will produce the same output.
Consider another example given below. Assume there is a Trainee class with Name and CGPA as their data members (consider both the members as public for this demonstration purpose). Another class Batch which comprise of a set of trainee objects (like an array) to initialize them. We would like to use an iteration mechanism for the Batch class to iterate through each and every trainee object to display the trainee details.
</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    namespace IteratorDemo
    {
        public class Trainee
        {
            public string Name;
            public float CGPA;
            public Trainee(string nameValue, float CGPAValue)
            {
                Name = nameValue;
                CGPA = CGPAValue;
            }
        }
        public class Batch
        {
            private Trainee[] traineeArr;
            public Batch()
            {
                traineeArr = new Trainee[3];
                traineeArr[0] = new Trainee("John", 4.5f);
                traineeArr[1] = new Trainee("Dennis", 4.8f);
                traineeArr[2] = new Trainee("Carol", 4.7f);
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The code for the starter class is given below:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Program
    {
        static void Main(string[] args)
        {
            Batch bObj=new Batch();
            // Traverse through each of the items 
            foreach(Trainee tObj in bObj)
            {
                Console.WriteLine(tObj.Name+" "+tObj.CGPA);
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The above code will throw the following error: “foreach statement cannot operate on variables of type ‘Batch’ because it does not contain a public definition for GetEnumerator()”</p>
                            <p>This is because the array of Trainees is a custom collection. In order to enumerate through a custom collection, that particular class should implement IEnumberable interface.</p>
                            <p>The Batch class when implements the IEnumerable interface of the System.Collections namespace as shown below, the Batch class knows how to iterate through a set of Trainee objects.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Batch:IEnumerable
    {
        private Trainee[] traineeArr;
        public Batch()
        {
            traineeArr=new Trainee[3];
            traineeArr[0]=new Trainee("John",4.5f);
            traineeArr[0]=new Trainee("Dennis",4.8f);
            traineeArr[0]=new Trainee("Carol",4.7f);
        }
        #region IEnumerable Members
        public IEnumerator GetEnumerator()
        {
            return traineeArr.GetEnumerator();
        }
        #endregion
    }
</pre>
                                    </div>
                                </div>
                            </p>
                        </li>-->
                    </ul> <!--Sub Heading-->
                    <p><a href="#top">Top of page</a></p>

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_LangEnhancementsinC#3.0and4.0"></a>
                    <h2>Language Enhancements in C# 3.0 and C# 4.0</h2>    <!--Main Heading-->
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_IntroductionCSharp3.0"></a><strong>Introduction</strong><br />
                            <br />
                            <p>C# 3.0 ("C# Orcas") introduces several language extensions that are build on C# 2.0 to support the creation and use of higher order, functional style class libraries. The extensions enable construction of compositional APIs that have equal expressive power of query languages in domains such as relational databases and XML. The extensions include:</p>
                            <ul>
                                <li>Implicitly typed local variables, which permit the type of local variables to be inferred from the expressions used to initialize them.</li>
                                <li>Implicitly typed arrays, a form of array creation and initialization that infers the element type of the array from an array initializer.</li>
                                <li>Extension methods, which make it possible to extend existing types and constructed types with additional methods.</li>
                                <li>Lambda expressions, an evolution of anonymous methods that provides improved type inference and conversions to both delegate types and expression trees.</li>
                                <li>Object initializers, which ease construction and initialization of objects.</li>
                                <li>Anonymous types, which are tuple types automatically inferred and created from object initializers.</li>
                                <li>Query expressions, which provide a language integrated syntax for queries that is similar to relational and hierarchical query languages such as SQL and XQuery.</li>
                                <li>Expression trees, which permit lambda expressions to be represented as data (expression trees) instead of as code (delegates).</li>
                            </ul>
                        </li>

                        <li>
                            <a name="SM_ImplicitlyTypedLocalVariables"></a><strong>Implicitly Typed Local Variables</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#var_keyword">Demo</a></li>
                            </ul>

                            <p>An implicitly typed local variable is a local variable whose type is inferred from the expression that is used to initialize the variable. When you want to declare a local variable using “var” keyword, then the initialization of that variable should happen at the time of declaration itself. That means, we cannot defer the assignment of a variable declared as “var” after the declaration statement is completed. </p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    var i = 5;
    var s = "Hello";
    var d = 1.0;
    var numbers = new int[] {1, 2, 3};
    var orders = new Dictionary&lt;int,order&gt;();
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>
                                The following are examples of incorrect implicitly typed local variable declarations:
                            </p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    var x;               		// Error, no initializer to infer type from
    var y = {1, 2, 3};   	// Error, collection initializer not permitted
    var z = null;        	// Error, null type not permitted
    var u = x => x + 1;  	// Error, lambda expressions do not have a type
    var v = v++;         	// Error, initializer cannot refer to variable itself
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The var keyword may be used in the following contexts:</p>
                            <ul>
                                <li>
                                    In a for initialization statement<br /><br />

                                    for ( var x = 1; x < 10; x++)
                                </li>
                                <li>
                                    In a foreach initialization statement<br /><br />

                                    foreach(var item in list) { ... }

                                </li>
                                <li>
                                    In a using statement<br /><br />

                                    using (var file = new StreamReader("C:\\myfile.txt")) { ... }

                                </li>
                            </ul>
                        </li>

                        <li>
                            <a name="SM_DynamicKeyword"></a><strong>“dynamic” keyword</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#dynamic_keyword">Demo</a></li>
                            </ul>

                            <p>C# 4.0 introduces the “dynamic” keyword making the language dynamic typed language. The dynamic type enables the operations in which it occurs to bypass compile-time type checking. Instead, these operations are resolved at run time.</p>
                            <p>Type dynamic behaves like type object in most circumstances. However, operations that contain expressions of type dynamic are not resolved or type checked by the compiler. The compiler packages together information about the operation, and that information is later used to evaluate the operation at run time. As part of the process, variables of type dynamic are compiled into variables of type object.</p>
                            <p>The following example contrasts a variable of type dynamic to a variable of type object.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Program
    {
        static void Main(string[] args)
        {
            dynamic dyn = 1;
            object obj = 1;
            // Rest the mouse pointer over dyn and obj to see their 
            // types at compile time.
            Console.WriteLine(dyn.GetType());
            Console.WriteLine(obj.GetType());
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>When executed, the output would be as follows:</p>
                            <p>System.Int32<br />System.Int32</p>
                            <p>Now, add the below two statements after the initialization statements in the above code snippet.</p>
                            <p>dyn = dyn + 3;<br />obj = obj + 3;</p>
                            <p>We would notice that the code results in compile-time error.</p>
                            <p>Operator '+' cannot be applied to operands of type 'object' and 'int'</p>
                            <p><strong>Point to Note:</strong> A compiler error is reported for the attempted addition of an integer and an object in expression obj + 3. However, no error is reported for dyn + 3. The expression that contains dyn is not checked at compile time because the type of dyn is dynamic.</p>
                            <p>The following table summarizes the key points about “var” and “dynamic” keywords:</p>
                            <table class="content-table">
                                <tr>
                                    <th>var</th>
                                    <th>Dynamic types</th>
                                </tr>
                                <tr>
                                    <td>Introduced in C# 3.0</td>
                                    <td>Introduced in C# 4.0</td>
                                </tr>
                                <tr>
                                    <td>It is statically typed i.e. the compiler determines and assigns the most appropriate type. </td>
                                    <td>It is dynamically typed i.e. compiler does not determine the type but it is inferred at run time.</td>
                                </tr>
                                <tr>
                                    <td>
                                        It is mandatory to initialize at the time of declaration.
                                        <br />
                                        var name = "Albus";
                                        <br />
                                        The var keyword instructs the compiler to infer the type of the variable from the expression on the right side of the initialization statement.
                                    </td>
                                    <td>
                                        It is mandatory to initialize at the time of declaration.
                                        <br />
                                        dynamic num = 2;
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        Once assigned type cannot be changed
                                        <br />
                                        var classCode = "A";
                                        <br />
                                        classCode = 1;
                                    </td>
                                    <td>
                                        Type can be changed in subsequent lines
                                        <br />
                                        dynamic classCode = "A";
                                        <br />
                                        classCode = 1;
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        Intellisense is supported.
                                        <br />
                                        var numberObj = new List&lt;int&gt;();
                                        <br />
                                        When we type numberObj, intellisense displays all the methods of List.
                                    </td>
                                    <td>
                                        Intellisense is not supported
                                        <br />
                                        dynamic numberObj = new List&lt;int&gt;();
                                        <br />
                                        When we type numberObj, intellisense doesn’t display any information.
                                    </td>
                                </tr>
                                <tr>
                                    <td>Errors are caught at compile time.</td>
                                    <td>Errors are caught at runtime </td>
                                </tr>
                            </table>
                        </li>

                        <li>
                            <a name="SM_ImplicitlyTypedArrays"></a><strong>Implicitly Typed Arrays</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_ImplicitlyTypedArrays">Demo</a></li>
                            </ul>

                            <p>In an implicitly typed array creation expression, the type of the array instance is inferred from the elements specified in the array initializer. Specifically, the set formed by the types of the expressions in the array initializer must contain exactly one type to which each type in the set is implicitly convertible, and if that type is not the null type, an array of that type is created. If exactly one type cannot be inferred, or if the inferred type is the null type, a compile-time error occurs.</p>
                            <p>The following are examples of implicitly typed array creation expressions:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    var a = new[] { 1, 10, 100, 1000 };                // int[]
    var b = new[] { 1, 1.5, 2, 2.5 };            	// double[]
    var c = new[] { "hello", null, "world” };      	// string[]
    var d = new[] { 1, "one", 2, "two" };         	// Error
</pre>
                                    </div>
                                </div>
                            </p>
                        </li>

                        <li>
                            <a name="SM_ObjectInitializers"></a><strong>Object Initializers</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_ObjectInitializers">Demo</a></li>
                            </ul>

                            <p>An object initializer consists of a sequence of member initializers, enclosed by “{“ and “}” tokens and separated by commas. Each member initializer must name an accessible field or property of the object being initialized, followed by an equals sign and an expression or an object or collection initializer. It is an error for an object initializer to include more than one member initializer for the same field or property. It is not possible for the object initializer to refer to the newly created object it is initializing.</p>
                            <p>The following class represents a point with two coordinates:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Point
    {
       int x, y;
       public int X { get { return x; } set { x = value; } }
       public int Y { get { return y; } set { y = value; } }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>An instance of Point can be created as follows:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    var a = new Point { X = 0, Y = 1 };</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The following class represents a rectangle created from two points:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Rectangle
    {
       Point p1, p2;
       public Point P1 { get { return p1; } set { p1 = value; } }
       public Point P2 { get { return p2; } set { p2 = value; } }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>An instance of Rectangle can be created and initialized as follows:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    var r = new Rectangle 
    {
       P1 = new Point { X = 0, Y = 1 },
       P2 = new Point { X = 2, Y = 3 }
    };
</pre>
                                    </div>
                                </div>
                            </p>
                        </li>

                        <li>
                            <a name="SM_CollectionInitializers"></a><strong>Collection Initializers</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_CollectionInitializers">Demo</a></li>
                            </ul>

                            <p>Collection Initializers, like object initializers are introduced in C# 3.0. They provides you a simple syntax for creating instances of a collection. Any object that is implementing System.Collections.Generic.ICollection&lt;T&gt; can be initialized with collection initializer. A collection initializer consists of a sequence of element initializers, enclosed by { and } tokens and separated by commas. Each element initializer specifies an element to be added to the collection object being initialized, and consists of a list of expressions enclosed by { and } tokens and separated by commas.</p>
                            <p>The following is an example of an object creation expression that includes a collection initializer:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    List&lt;int&gt; digits = new List&lt;int&gt; { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The following class represents a customer with a name and a list of phone numbers:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Customer
    {        
        public string CustomerName { get; set; }
        List&lt;long&gt; phones = new List&lt;long&gt;();
        public List&lt;long&gt; Phones { get { return phones; } }
    }
    static void Main(string[] args)
    {
        var customers = new List&lt;Customer&gt;
        {
            new Customer {                    
                CustomerName = "Ted",
                Phones = { 9988776655, 9977553311}
            },
            new Customer {                    
                CustomerName = "Fred",
                Phones = { 9583476451, 9667544321}
            }
        };
        foreach (var item in customers)
        {
            Console.WriteLine(item.CustomerName + "\t" + item.Phones[0] + "\t" + item.Phones[1]);
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                        </li>

                        <li>
                            <a name="SM_ExtensionMethods"></a><strong>Extension Methods</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_ExtensionMethods">Demo</a></li>
                                <li class="last"><a href="../Quiz/LanguageEnhancements.htm">Quiz</a></li>
                            </ul>

                            <p>Extension methods are introduced in C# 3.0. They are static methods that can be invoked using instance method syntax. In effect, extension methods make it possible to extend existing types and constructed types with additional methods.</p>
                            <p>The first parameter of an extension method can have no modifiers other than this. </p>
                            <p>An extension method enables us to add our own methods to existing types without a need to create a new derived type, or modify the original types.</p>
                            <p>An example of extension method which takes a string as a parameter and returns the title case of the same statement.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public static class ExtensionClass
    {
        public static string ToCapitalize(this string str)
        {
            TextInfo text = new CultureInfo("en-US", false).TextInfo;
            return text.ToTitleCase(str);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            string message = "a quick brown fox jumps over the lazy dog";
            Console.WriteLine("Result = {0}", message.ToCapitalize());
        }
    }
                                        </pre>
                                    </div>
                                </div>
                            </p>
                        </li>


                    </ul> <!--Sub Heading-->
                    <p><a href="#top">Top of page</a></p>

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_Delegates"></a>
                    <h2>Delegates</h2>    <!--Main Heading-->
                    <ul class="getStartedList">

                        <li>
                            <a name="SM_NeedforDelegates"></a><strong>Need for Delegates</strong><br />
                            <br />
                            <p>Consider the following example. There is a class for various Greetings. The user class needs to invoke this method.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Greetings
    {
        public static void Hello(string str)
         {
           Console.WriteLine("Hello " + str);
         }
        public static void Bye(string str)
        {
           Console.WriteLine("Bye " + str);
        }
    }
    public class User
    {
        string name;
        string gender;
        public User(string name,string gender)
        {
            this.name = name;
            this.gender = gender;
        }
        public void GreetUser()
        {
            if (gender =="female")
               name = "Ms. " + name;
            else if (gender == "male")
                name = "Mr. " + name;
            /* Need to call one of the 
            methods based on requirement */
            //Greetings.Hello(name);
            //Greetings.Bye(name);
        }
    }
    public class Program
     {
         public static void Main()
         {
    	    User userObj = new User("John", "male");
             userObj.GreetUser();
             //Statements to process userObj
             userObj.GreetUser();
         }
     }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The information about which method to invoke is not available with User class. This information needs to be passed on runtime. Based on the information, an appropriate method would be called.</p>
                            <p>A possible way to achieve this is as follows:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class User
    {
        string name;
        string gender;
        public User(string name,string gender)
        {
            this.name = name;
            this.gender = gender;
        }
  
        public void GreetUser(string select)
        {
            if (gender =="female")
               name = "Ms. " + name;
            else if (gender == "male")
                name = "Mr. " + name;
            if(select=="Hello")
            Greetings.Hello(name);
          else if (select == "Bye")
            Greetings.Bye(name);
        }
     }
    public class Program
     {
         public static void Main()
         {
    	    User userObj = new User("John", "male");
             userObj.GreetUser("Hello");
             //Statements to process userObj
             userObj.GreetUser("Bye");     
         }
     }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The suggested solution is acceptable if there are only a few methods to be chosen from and no new method is added in future. If there are many methods to be chosen from, code related to conditional statements would be very long. If new method is added in future, code related to conditional statements would have to modify accordingly. Can we think of a way by which the method to be called is passed as a parameter and invoked by the receiving method?</p>
                            <p>Wish we could have something like this….</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class User
     {
        string name;
        string gender;
        public User(string name,string gender)
        {
            this.name = name;
            this.gender = gender;
        }
 
        public void GreetUser(Method select)
        {
            if (gender =="female")
               name = "Ms. " + name;
            else if (gender == "male")
                name = "Mr. " + name;
            select(name);
        }
    }
    public class Program
     {
         public static void Main()
         {
    	    User userObj = new User("John", "male");
             userObj.GreetUser(Greetings.Hello);
             //Statements to process userObj
             userObj.GreetUser(Greetings.Bye);     
         }
     }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The last solution offers a big advantage:</p>
                            <ul>
                                <li>The receiving method (GreetUser) is independent of the choice of method to be called. </li>
                                <li>Hence, it need not be modified based even if a new method is added tomorrow. </li>
                                <li>We achieve a separation of concern</li>
                            </ul>
                            <p>But the last solution is syntactically not acceptable in C#:</p>
                            <ul>
                                <li>When the method is accepted as any other type, there is no information about what will be the parameters and parameter types, as well as return type of the passed method</li>
                                <li>Hence, when the method accepted as parameter is called, it cannot be verified whether it is a valid call or not.</li>
                                <li>If more than one methods need to be invoked as a chain, all these methods will have to passed, implying change in the signature of receiving method. This means that this method is independent only in a limited way </li>
                            </ul>
                        </li>
                    
                        <li>
                            <a name="SM_UsingDelegates"></a><strong>Using Delegates</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="http://digitaltutor/#/video/6/12/0" target="_blank">Video</a></li>
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo1_Delegates">Demo</a></li>
                                <li class="last"><a href="../Assignments/AdvancedCSharpAssignments.htm#A1_Delegates">Assignment</a></li>
                            </ul>



                            <p>To solve the problems in the last solution, C# provides for the concept of Delegates. A delegate can be declared with a specific signature similar to a method:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public delegate void GreetDelegate(string name);</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The delegate is a class which can be referenced and instantiated. A method having the same signature as the delegate has to be passed at the time of instantiation.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    GreetDelegate greetDelRef = new GreetDelegate(Greetings.Hello);</pre>
                                    </div>
                                </div>
                            </p>
                            <p>More method can be added to same delegate reference</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    greetDelRef += new GreetDelegate(Greetings.Bye);</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The same method can be added more than once</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    greetDelRef += new GreetDelegate(Greetings.Hello);</pre>
                                    </div>
                                </div>
                            </p>
                            <p>An added method can be removed</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    greetDelRef -= new GreetDelegate(Greetings.Bye);</pre>
                                    </div>
                                </div>
                            </p>
                            <p>Trying to add or delete a method, which does not match delegate signature, will result into compile time error. This is to ensure type –safety.</p>
                            <p>All the currently referenced methods can be invoked in a chain by invoking the delegate reference
A delegate reference can be passed to a method that accepts parameter of the delegate type.
</p>
                            <p>The solution to the earlier problem is given below.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class User
    {
        string name;
        string gender;
        public User(string name,string gender)
        {
        this.name = name;
        this.gender = gender;
        }
        public void GreetUser(GreetDelegate greetDel)
        {
        if (gender =="female")
            name = "Ms. " + name;
        else if (gender == "male")
            name = "Mr. " + name;
        greetDel(name);
        }
    }
    public static void Main()
    {
        GreetDelegate greetDel;
        User userObj = new User("John", "male");
        greetDel = 
            new GreetDelegate(Greetings.Hello);
        userObj.GreetUser(greetDel);
        //Statements to process userObj
        greetDel = 
            new GreetDelegate(Greetings.Bye);
        userObj.GreetUser(greetDel);     
    }</pre>
                                    </div>
                                </div>
                            </p>
                            <p>Synchronous delegates are used when you invoke the delegate and wait for the return value to arrive. You will not be able to do any operation in the period between you invoke the method and when the return value arrives. It is not suitable for operations that might require a lot of time. For Example: Considering the example of the educator given in the first slide of delegates, if we use synchronous delegates, after giving you the assignment, the educator will just wait for you to complete your assignment and do nothing till you complete.</p>
                            <p>Asynchronous delegates are used when you do not want to wait for the results to arrive and continue doing some other processing. This is typical in a scenario where you know the method pointed by the delegate will take time to finish execution and might stall the application. For Example: Considering the same example as above, after giving you the assignment, instead of simply wasting time by waiting for you to complete, the educator may continue with some of his other works like evaluation, slide preparation etc. After completing your work, you will report it to the educator, upon which he may process your assignments.</p>
                            <p>.NET supports both synchronous & asynchronous delegates. The Invoke( ) method is used for synchronously invoking the current method. Asynchronous delegates allow the application to continue with other jobs while the delegate performs its work. The BeginInvoke( ) and EndInvoke( ) are used for invoking the current method asynchronously.</p>
                            <p>Delegates can wrap private methods, hence should be used with care. It is possible for a method to invoke a private of some other class if it was wrapped and passed in a delegate</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Greetings
    {
        public static void Hello(string str)
        {
        Console.WriteLine("Hello " + str);
        }
        public static void Bye(string str)
        {
        Console.WriteLine("Bye " + str);
        }
    }
    public delegate void GreetDelegate(string name);
    public delegate void Print();
    class DelegateUser
    {
        public static void InvokeDelegate(Print printDel)
        {
            printDel();
        }
    }
    class DelegateGiver
    {
        private static void PrintMessage()
        {
            Console.WriteLine("I am a private method");
        }
        public static void Main()
        {
            Print printDel = new Print(PrintMessage);
            DelegateUser.InvokeDelegate(printDel);
        }
    }</pre>
                                    </div>
                                </div>
                            </p>
                        </li>

                        <li>
                            <a name="SM_UsingDelegatesForMultipleMethods"></a><strong>Using Delegates for multiple methods</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="http://digitaltutor/#/video/6/12/1" target="_blank">Video</a></li>
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo1_DelegatesForMultipleMethods">Demo</a></li>
                            </ul>



                            <p>When more than one method is added to the same delegate, they execute as a chain. Usually, the return type of such methods is void. In case, the methods return some other type, we can get the result of the last method of the chain only. An exception thrown in any one of the methods in the invocation list terminates the chain and prevents any following methods to catch the exception
The method GetInvocationList() can be used to get the list of all the methods, access each method separately and to get the return value.
</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public delegate int SomeDelegate(int num1, int num2);
    class DelegateDemo
    {
        public int Add(int num1, int num2)
        {
            Console.Write("Addition:");
            return num1 + num2;
        }
        public int Sub(int num1, int num2)
        {
            Console.Write("Subtraction:");
            return num1 - num2;
        }
        public int Mul(int num1, int num2)
        {
            Console.Write("Multiplication:");
            return num1 * num2;
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            DelegateDemo delObj = new DelegateDemo();
            SomeDelegate del = new SomeDelegate(delObj.Add);
            del += new SomeDelegate(delObj.Sub);
            del += new SomeDelegate(delObj.Mul);
            //Work Around for Handling Multiple Return Values in Multicast Delegate
            foreach (SomeDelegate delItem in del.GetInvocationList())
            {
                try
                {
                    Console.WriteLine(delItem.Method.Name);
                    int result = delItem(20, 10);
                    Console.WriteLine(result);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.Message);
                }
            }
        }
    }</pre>
                                    </div>
                                </div>
                            </p>
                        </li>
                        
                        <li>
                            <a name="SM_AnonymousMethods"></a><strong>Anonymous Methods</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_AnonymousTypes">Demo</a></li>
                                <li class="last"><a href="../Quiz/Delegates.htm">Quiz</a></li>
                            </ul>





                            <p>Prior to C# 2.0, the only way to declare a delegate was to use the named methods. C# 2.0 introduces the concept of anonymous methods (i.e., a code block which doesn’t have a name). The advantage of using the anonymous method is it reduces the coding overhead while instantiating the delegate as there is no need to create a special method and call the same. Behind the scenes, these anonymous methods exists like a normal method but the only thing is we cannot explicitly call them in our code. </p>
                            <p>The above code snippet used for multicast delegates can be implemented using anonymous methods as below:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre> class Program
    {
        static void Main(string[] args)
        {
            SomeDelegate del = new SomeDelegate(delegate(int a, int b) { return a + b; });
            del += new SomeDelegate(delegate(int a, int b) { return a - b; });
            del += new SomeDelegate(delegate(int a, int b) { return a * b; });
            
            foreach (SomeDelegate delItem in del.GetInvocationList())
            {
                try
                {
                    Console.WriteLine(delItem.Method.Name);
                    int result = delItem(20, 10);
                    Console.WriteLine(result);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.Message);
                }
            }
        }
    }</pre>
                                    </div>
                                </div>
                            </p>
                            <p>When the above code snippet is executed, we observe the following output:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    &lt;Main&gt;b__0
    30
    &lt;Main&gt;b__1
    10
    &lt;Main&gt;b__2
    200</pre>
                                    </div>
                                </div>
                            </p>
                            <p>We notice that the class “DelegateDemo” is not required to be created as the logic of all the three methods are written inline at the time of instantiating the delegate object. The above output also tells us that even though we are not giving any name to the code block, the system internally gives a name to the anonymous block.</p>
                        </li>

                        <li>
                            <a name="SM_GenericDelegates"></a><strong>Generic Delegates</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_GenericDelegatesAndLambdaExpressions">Demo</a></li>
                            </ul>






                            <p>A delegate can be used in the following scenarios: </p>
                            <ul style="list-style-type:decimal">
                                <li>If the code doesn't need access to any other attributes or method of the class from which logic needs to be processed.</li>
                                <li>Event driven implementation needs to be done. </li>
                            </ul>
                            <p>Whenever we want to use delegates in our applications, typically we use the following procedure:</p>
                            <ul>
                                <li>Define a custom delegate that matches the signature of the method. </li>
                                <li>Create an instance of a delegate and point it to a method. </li>
                                <li>Invoke the method. </li>
                            </ul>
                            <p>As .NET Framework evolved, a lot of new flavors have been added to keep implementation simple and optimized. The generic delegates, Func and Action, were introduced in the .NET Framework 3.5. They both are very useful when we want to reduce duplication of code by simply eliminating the above procedure. Let us understand the functionality of each of these delegates with an example.</p>

                            <h3>
                                Func&lt;&gt;:
                            </h3>
                            <p>This generic delegate is used in situations where we want to point to a method which returns some value. The method it points to can take a maximum of 16 input parameters and can return a value. The return value has to be the last parameter in the parameter list passed to the Func&lt;&gt; delegate signature. </p>
                            <p>Example: Func&lt;int, int, long&gt; represents a delegate which takes two int parameters as input and returns a long result.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Category
    {
        public short CategoryId { get; set; }
        public string CategoryName { get; set; }  
        public Category SearchCategory(short categoryId)
        {
            List&lt;Category&gt; lstCategories = new List&lt;Category&gt;()
            {
                new Category { CategoryId=1, CategoryName="Home" },
                new Category { CategoryId=2, CategoryName="Furniture" },
                new Category { CategoryId=3, CategoryName="Apparels" },
                new Category { CategoryId=4, CategoryName="Electronics" }
            };
            Category cat = null;
            foreach (Category item in lstCategories)
            {
                if (item.CategoryId == categoryId)
                {
                    cat = item;
                    break;
                }
            }
            return cat;
        }
    }
    class Program
    {        
        static void Main(string[] args)
        {
            Category catObj = new Category();           
            Console.Write("Enter the Category ID : ");
            short catId = Convert.ToInt16(Console.ReadLine());
            Category category = catObj.SearchCategory(catId);
            if (category != null)
            {
                Console.WriteLine("Category ID = {0}", category.CategoryId);
                Console.WriteLine("Category Name = {0}", category.CategoryName);
            }
            else
                Console.WriteLine("Sorry. No data found");
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>We can replace the method, SearchCategory written in the Category class with a Generic Delegate Func&lt;&gt; as shown below:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Category
    {
        public short CategoryId { get; set; }
        public string CategoryName { get; set; }
        <strong>public Func&lt;short, Category&gt; SearchCategory = delegate(short categoryId)
        {
            List&lt;Category&gt; lstCategories = new List&lt;Category&gt;()
            {
                new Category { CategoryId=1, CategoryName="Home" },
                new Category { CategoryId=2, CategoryName="Furniture" },
                new Category { CategoryId=3, CategoryName="Apparels" },
                new Category { CategoryId=4, CategoryName="Electronics" }
            };
            Category cat = null;
            foreach (Category item in lstCategories)
            {
                if (item.CategoryId == categoryId)
                {
                    cat = item;
                    break;
                }
            }
            return cat;
        };</strong>
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The code highlighted above works exactly the same way as that of the SearchCategory method written earlier in the Category class. From the above code snippet, we can conclude that any method which takes either zero or more input parameters (maximum 16) and return a value can be written using the Func delegate.</p>


                            <h3>Action&lt;&gt;:</h3>
                            <p>The Action&lt;&gt; generic delegate is similar to Func&lt;&gt; delegate except that it takes a maximum of 16 input parameters but doesn’t return any result. Methods with void as the return type are used with Action delegate.</p>
                            <p>For Example:</p>
                            <ul>
                                <li><strong>Action&lt;&gt;</strong> indicates that the method referred takes no parameter and doesn’t return a value</li>
                                <li><strong>Action&lt;T&gt;</strong> indicates that the method referred takes one input parameter and returns no result</li>
                                <li><strong>Action&lt;T1, T2&gt;</strong> indicates that the method referred takes two input parameters and returns no result</li>
                                <li><strong>Action&lt;T1,T2, …, T16&gt;</strong> indicates that the method referred takes 16 input parameters and returns no result</li>
                            </ul>
                            <p>The code written for the Func&lt;&gt; delegate can be replaced with the Action&lt;&gt; delegate as shown below.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Category
    {
        public short CategoryId { get; set; }
        public string CategoryName { get; set; }
        public Action&lt;short&gt; SearchCategory = delegate(short categoryId)
        {
            List&lt;Category&gt; lstCategories = new List&lt;Category&gt;()
            {
                new Category { CategoryId=1, CategoryName="Home" },
                new Category { CategoryId=2, CategoryName="Furniture" },
                new Category { CategoryId=3, CategoryName="Apparels" },
                new Category { CategoryId=4, CategoryName="Electronics" }
            };
            Category category = null;
            foreach (Category item in lstCategories)
            {
                if (item.CategoryId == categoryId)
                {
                    category = item;
                    break;
                }
            }
            if (category != null)
            {
                Console.WriteLine("Category ID = {0}", category.CategoryId);
                Console.WriteLine("Category Name = {0}", category.CategoryName);
            }
            else
                Console.WriteLine("Sorry. No data found");
        };
    }
    class Program
    {        
        static void Main(string[] args)
        {
            Category catObj = new Category();           
            Console.Write("Enter the Category ID : ");
            short catId = Convert.ToInt16(Console.ReadLine());
            catObj.SearchCategory(catId);            
        }
    }</pre>
                                    </div>
                                </div>
                            </p>
                            
                       </li>




                    </ul> <!--Sub Heading-->
                    <p><a href="#top">Top of page</a></p>

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_LINQ"></a>
                    <h2>LINQ</h2>    <!--Main Heading-->
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_LambdaExpressions"></a><strong>Lambda Expressions</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_GenericDelegatesAndLambdaExpressions">Demo</a></li>
                                <li class="last"><a href="../Assignments/AdvancedCSharpAssignments.htm#AA_LambdaExpressions">Assignment</a></li>
                            </ul>


                            <p>Lambda Expressions were introduced as part of C# 3.0. They help in making the usage of Anonymous methods more concise. When the code which has Lambda Expressions are compiled, they get converted into anonymous methods based on the rules of lambda expression conversions. It is a symbolic way of representing an anonymous method. The symbol used to represent a lambda expression is “=&gt;” where the left side of the operator represent the parameters that you may wish to pass to a method and the right side of the operator represents the method body. </p>
                            <br />
                            <h3>Syntax:</h3>
                            <p>([parameters])	=&gt;	expression (or) statement block;</p>
                            <br />
                            <h3>Examples:</h3>
                            <ul>
                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    x =&gt; { return x * x; }		// Also called statement lambda since right hand side has a statement block
</pre>
                                        </div>
                                    </div>

                                </li>


                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    x =&gt;x * x;			// Also called expression lambda since right hand side has only an expression and no statements or curly braces
</pre>
                                        </div>
                                    </div>

                                </li>


                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    customers.Find(name => name.Equals(“Fred”));
</pre>
                                        </div>
                                    </div>

                                </li>


                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    () => Console.Write(“Hello”);
</pre>
                                        </div>
                                    </div>

                                </li>


                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    int[] scores = { 90, 71, 82, 93, 75, 82 };
    scores.Where(n => n &gt; 80).Count();
</pre>
                                        </div>
                                    </div>

                                </li>

                            </ul>





                        </li>

                        <li>
                            <a name="SM_LINQtoObjects"></a><strong>LINQ to Objects</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">

                                <li class="last"><a href="../Exercises/AdvancedCSharpExercises.htm#E_LINQToObjects">Exercise</a></li>
                                <li class="last"><a href="../Assignments/AdvancedCSharpAssignments.htm#AA_Delegates_AnonymousMethods">Assignment</a></li>
                                <li class="last"><a href="../Quiz/LINQ.htm">Quiz</a></li>
                            </ul>

                            <p>Today, the industry has reached a stable point in the evolution of object-oriented (OO) programming technologies. Programmers now take for granted features like classes, objects, and methods. In looking at the current and next generation of technologies, it has become apparent that the next big challenge in programming technology is to reduce the complexity of accessing and integrating information that is not natively defined using OO technology. The two most common sources of non-OO information are relational databases and XML.</p>
                            <p>Rather than add relational or XML-specific features to our programming languages and runtime, with the LINQ project we have taken a more general approach and are adding general-purpose query facilities to the .NET Framework that apply to all sources of information, not just relational or XML data. This facility is called .NET Language-Integrated Query (LINQ).</p>
                            <p>We use the term language-integrated query to indicate that query is an integrated feature of the developer's primary programming languages (for example, Visual C#, Visual Basic). Language-integrated query allows query expressions to benefit from the rich metadata, compile-time syntax checking, static typing and IntelliSense that was previously available only to imperative code. Language-integrated query also allows a single general purpose declarative query facility to be applied to all in-memory information, not just information from external sources.</p>
                            <p>.NET Language-Integrated Query defines a set of general purpose standard query operators that allow traversal, filter, and projection operations to be expressed in a direct yet declarative way in any .NET-based programming language. The standard query operators allow queries to be applied to any IEnumerable&lt;T&gt;-based information source. LINQ allows third parties to augment the set of standard query operators with new domain-specific operators that are appropriate for the target domain or technology. More importantly, third parties are also free to replace the standard query operators with their own implementations that provide additional services such as remote evaluation, query translation, optimization, and so on. By adhering to the conventions of the LINQ pattern, such implementations enjoy the same language integration and tool support as the standard query operators.</p>

                            <h3>Example:</h3>
                            <div class="codesnippet">
                                <div>
                                    <pre>    static void Main(string[] args)
    {
        string[] names = { "Burke", "Connor", "Frank", 
                    "Everett", "Albert", "George", 
                    "Harris", "David" };
        IEnumerable&lt;string&gt; query = from s in names
                                    where s.Length == 5
                                    orderby s
                                    select s.ToUpper();
        foreach (string item in query)
            Console.WriteLine(item);
    }
</pre>
                                </div>
                            </div>
                        </li>

                        <li>
                            <a name="SM_QueryExpressions"></a><strong>Query Expressions</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_QueryExpressions">Demo</a></li>
                                <li class="last"><a href="../Assignments/AdvancedCSharpAssignments.htm#AA_QueryExpressions">Assignment</a></li>
                            </ul>


                            <p>Query expressions are written in a declarative query syntax introduced in C# 3.0. By using query syntax, you can perform complex filtering, ordering, and grouping operations on data sources with a minimum of code. You use the same basic query expression patterns to query and transform data in SQL databases, ADO.NET Datasets, XML documents and streams, and .NET collections.</p>
                            <p>Following are some of the basic guidelines for working with Query Expressions:</p>
                            <ul>
                                <li>Query expressions can be used to query and to transform data from any LINQ-enabled data source. For example, a single query can retrieve data from a SQL database, and produce an XML stream as output.</li>
                                <li>Query expressions are easy to master because they use many familiar C# language constructs</li>
                                <li>The variables in a query expression are all strongly typed, although in many cases you do not have to provide the type explicitly because the compiler can infer it</li>
                                <li>A query is not executed until you iterate over the query variable in a foreach statement. This is called deferred execution.</li>
                                <li>Queries that return a singleton value like Average, Count, First, Max, etc. are executed immediately.It executes immediately because the query must produce a sequence to calculate the singleton result.To force immediate execution of a query that does not produce a singleton value, you can call the ToList method, the ToDictionary method, or the ToArray method on a query or query variable.It is useful when you want to cache the results of a query</li>
                                <li>At compile time, query expressions are converted to Standard Query Operator method calls according to the rules set forth in the C# specification. Any query that can be expressed by using query syntax can also be expressed by using method syntax. However, in most cases query syntax is more readable and concise</li>
                                <li>As a rule when you write LINQ queries, we recommend that you use query syntax whenever possible and method syntax whenever necessary. There is no semantic or performance difference between the two different forms. Query expressions are often more readable than equivalent expressions written in method syntax</li>
                                <li>Some query operations, such as Count or Max, have no equivalent query expression clause and must therefore be expressed as a method call. Method syntax can be combined with query syntax in various ways</li>
                                <li>Query expressions can be compiled to expression trees or to delegates, depending on the type that the query is applied to. IEnumerable&lt;T&gt; queries are compiled to delegates. IQueryable&lt;T&gt; queries are compiled to expression trees</li>
                            </ul>




                            <p>Lambda Expressions were introduced as part of C# 3.0. They help in making the usage of Anonymous methods more concise. When the code which has Lambda Expressions are compiled, they get converted into anonymous methods based on the rules of lambda expression conversions. It is a symbolic way of representing an anonymous method. The symbol used to represent a lambda expression is “=&gt;” where the left side of the operator represent the parameters that you may wish to pass to a method and the right side of the operator represents the method body. </p>
                            <br />
                            <h3>Syntax:</h3>
                            <p>([parameters])	=&gt;	expression (or) statement block;</p>
                            <br />
                            <h3>Examples:</h3>
                            <ul>
                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    x =&gt; { return x * x; }		// Also called statement lambda since right hand side has a statement block
</pre>
                                        </div>
                                    </div>

                                </li>


                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>	x =&gt;x * x;			// Also called expression lambda since right hand side has only an expression and no statements or curly braces
</pre>
                                        </div>
                                    </div>

                                </li>


                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>	customers.Find(name => name.Equals(“Fred”));
</pre>
                                        </div>
                                    </div>

                                </li>


                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>	() => Console.Write(“Hello”);
</pre>
                                        </div>
                                    </div>

                                </li>


                                <li>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    int[] scores = { 90, 71, 82, 93, 75, 82 };
    scores.Where(n => n &gt; 80).Count();
</pre>
                                        </div>
                                    </div>

                                </li>

                            </ul>






                        </li>

                    </ul> <!--Sub Heading-->
                    <p><a href="#top">Top of page</a></p>

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_MemoryManagement"></a>
                    <h2>Memory Management</h2>    <!--Main Heading-->
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_Introduction"></a><strong>Introduction</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="http://digitaltutor/#/video/6/13/0" target="_blank">Video</a></li>
                               
                            </ul>



                            <p>Memory management is the key concern for any application(s) we develop as developers. In languages like C, the responsibility of cleaning the memory is with the developers themselves. Manual memory management can be both time-consuming and difficult. In some cases, it may be required that some action be taken before freeing the memory e.g. close an open file before memory allocated to that file is released. Developer needs to write the clean-up code in such cases.</p>
                            <p>In C#, automatic memory management is provided so that developers are freed from this burden and can concentrate only on implementation of business logic. In majority of cases, automatic memory management increases code quality and enhances developer productivity without impacting the performance. This is done using garbage collector.</p>
                            <p>Garbage Collection occurs when one of the following conditions is TRUE:</p>
                            <ul>
                                <li>The system has low physical memory</li>
                                <li>The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold</li>
                                <li>The GC.Collect() method is called</li>
                            </ul>
                            <p>The memory management life cycle of an object is as follows: </p>
                            <ul style="list-style-type:decimal">
                                <li>When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</li>
                                <li>If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction. The garbage collector may choose to analyze code to determine which references to an object may be used in the future. For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</li>
                                <li>Once the object is eligible for destruction, at some unspecified later time the destructor, if any, for the object is run. Unless overridden by explicit calls, the destructor for the object is run once only.</li>
                                <li>Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</li>
                                <li>Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</li>
                            </ul>
                            <p>Consider the below example on how memory is automatically reclaimed by the garbage collector.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    namespace MemoryManagement
    {
        class A
        {
            ~A()
            {
                Console.WriteLine("Destroy instance of A");
            }
        }
        class B
        {
            object Ref;
            public B(object o)
            {
                Ref = o;
            }
            ~B()
            {
                Console.WriteLine("Destroy instance of B");
            }
        }
        class Test
        {
            static void Main()
            {
                A a = new A();
                B b = new B(a);
                a = null;
                GC.Collect();
                GC.WaitForPendingFinalizers();
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    Output: 
    Destroy instance of B
    Destroy instance of A
</pre>


                                    </div>
                                </div>
                            </p>
                            <p><strong>Note:</strong> If the .Net Framework selected is 3.5, then the output would be as shown below</p>

                                <div class=" codesnippet">

                                    <div>
                                        <pre>Output
    Destroy instance of A
    Destroy instance of B
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>Instead of making the reference of class A point to null, if we make the reference of class B point to null, then the output will be as follows:</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    Output: 
    Destroy instance of B
    Destroy instance of A
</pre>
                                    </div>


                                </div>
                            </p>
                            <p>The statement GC.Collect() forces an immediate garbage collection of all generations. </p>
                            <p>The statement GC.WaitForPendingFinalizers() suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</p>
                            <p>Whenever garbage collector runs, it automatically frees the memory for unused objects. GC will invoke the destructor to free the memory for unused objects. But this is implicit call, programs cannot invoke explicitly and the automatic garbage collection is unpredictable. That’s where we want to implement the destruction method by making use of IDisposable interface.</p>





                        </li>

                        <li>
                            <a name="SM_IDisposable"></a><strong>IDisposable interface and Dispose() method</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="http://digitaltutor/#/video/6/13/1" target="_blank">Video</a></li>
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_MemoryManagement">Demo</a></li>
                            </ul>


                            <p>Developer can write a method containing the cleanup code and call this method whenever object’s role is completed. This method would be called by developer, and could have any name. Typically, it is known as Dispose(). The Dispose() method should not be virtual. The child class should not be allowed to override the parent class resource release logic. In the child class Dispose() method, call the parent class Dispose() method as the last statement. The IDisposable interface mandates its implementing classes to define the Dispose() method.</p>
                            <h3>“using” block:</h3>
                            <p>If a class implements IDisposable interface, it can be instantiated inside a “using” clause. The scope of the instance is limited to the “using” block in which it was declared. The Dispose() method of the object will automatically be called at the end of “using” block.</p>
                            <p>The life-time of the instance “myObj” is only within the using block.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    using System;
    class MyClass : IDisposable
    {
        public void Dispose()
        {
            //Cleanup Code
            //Call to base class dispose, if applicable
        }
    }
    class Program
    {
        public static void Main()
        {
            MyClass myObj1 = new MyClass();
            myObj1.Dispose();	//Call to myObj1.Dispose() has to be made
            using (MyClass myObj2 = new MyClass()) //Can be used only for IDisposable objects
            {
            } 		//Call to myObj2.Dispose() is automatically made
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>











                        </li>



                    </ul> <!--Sub Heading-->
                    <p><a href="#top">Top of page</a></p>

                    <!--<div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_FileHandling"></a>
                    <h2>File Handling</h2>    
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_FilesandStreams"></a><strong>Files and Streams</strong><br />
                            <br />
                            <ul>
                                <li>
                                    Files are unmanaged resources in .NET. When a file is opened for reading or writing, it becomes a stream. Stream is a sequence of bytes traveling from a source to a destination over a communication path. An input stream allows you to read data from a source file, and an output stream allows you to write data to a destination file.
                                    <br />
                                    <p style="text-align:center">
                                        <img src="Images/SM_FilesAndStreams_1.jpg" />
                                    </p>
                                </li>
                                <li>
                                    Files can be accessed in following ways:<br /><br />
                                    <table class="content-table">
                                        <tr>
                                            <th>Member Name</th>
                                            <th>Description</th>
                                        </tr>
                                        <tr>
                                            <td>Read</td>
                                            <td>Read access to the file. Data can be read from the file. Combine with Write for read/write access.</td>
                                        </tr>
                                        <tr>
                                            <td>ReadWrite</td>
                                            <td>Read and write access to the file. Data can be written to and read from the file.</td>
                                        </tr>
                                        <tr>
                                            <td>Write</td>
                                            <td>Write access to the file. Data can be written to the file. Combine with Read for read/write access.</td>
                                        </tr>

                                    </table>

                                </li>
                                <li>
                                    Files can be used in various modes:<br />
                                    <br />
                                    <table class="content-table">
                                        <tr>
                                            <th>Member name</th>
                                            <th>Description</th>
                                        </tr>
                                        <tr>
                                            <td>Append</td>
                                            <td>Opens the file if it exists and seeks to the end of the file, or creates a new file. This requires FileIOPermissionAccess.Append permission.FileMode.Append can be used only in conjunction with FileAccess.Write. Trying to seek to a position before the end of the file throws an IOException exception, and any attempt to read fails and throws a NotSupportedException exception.</td>
                                        </tr>
                                        <tr>
                                            <td>Create</td>
                                            <td>Specifies that the operating system should create a new file. If the file already exists, it will be overwritten. This requiresFileIOPermissionAccess.Write permission. FileMode.Create is equivalent to requesting that if the file does not exist, use CreateNew; otherwise, use Truncate. If the file already exists but is a hidden file, an UnauthorizedAccessException exception is thrown.</td>
                                        </tr>
                                        <tr>
                                            <td>CreateNew</td>
                                            <td>Specifies that the operating system should create a new file. This requires FileIOPermissionAccess.Write permission. If the file already exists, an IOException exception is thrown.</td>
                                        </tr>
                                        <tr>
                                            <td>Open</td>
                                            <td>Specifies that the operating system should open an existing file. The ability to open the file is dependent on the value specified by theFileAccess enumeration. A System.IO.FileNotFoundException exception is thrown if the file does not exist.</td>
                                        </tr>
                                        <tr>
                                            <td>OpenOrCreate</td>
                                            <td>Specifies that the operating system should open a file if it exists; otherwise, a new file should be created. If the file is opened withFileAccess.Read, FileIOPermissionAccess.Read permission is required. If the file access is FileAccess.Write, FileIOPermissionAccess.Writepermission is required. If the file is opened with FileAccess.ReadWrite, both FileIOPermissionAccess.Read andFileIOPermissionAccess.Write permissions are required.</td>
                                        </tr>
                                        <tr>
                                            <td>Truncate</td>
                                            <td>Specifies that the operating system should open an existing file. When the file is opened, it should be truncated so that its size is zero bytes. This requires FileIOPermissionAccess.Write permission. Attempts to read from a file opened with FileMode.Truncate cause anArgumentException exception.</td>
                                        </tr>
                                    </table>
                                </li>
                            </ul>










                        </li>



                        <li>
                            <a name="SM_StreamReader"></a><strong>Stream Reader and Stream Writer</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_FileHandling">Demo</a></li>
                            </ul>


                            <p>StreamReader class provide methods can be used to Read text from a file.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Program
    {
        public static void Main()
        {
            fileStream = new FileStream(@"D:\CurrentDate.txt", FileMode.Open, FileAccess.Read);
            StreamReader streamReader = new StreamReader(fileStream);
            Console.WriteLine(streamReader.ReadToEnd());
            streamReader.Close();
            fileStream.Close();
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>StreamWriter class provide methods can be used to Write text to in a file.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Program
    {
        public static void Main()
        {
            FileStream fileStream;
            fileStream = new FileStream(@"D:\CurrentDate.txt",FileMode.Append, FileAccess.Write);
            StreamWriter streamWriter = new StreamWriter(fileStream);
            streamWriter.WriteLine(DateTime.Now);
            streamWriter.Close();
            fileStream.Close();
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>ReadToEnd() method of StreamReader reads the entire content of the file. StreamReader has other Read methods also. E.g. Read() reads one character at a time and ReadLine() reads one line at a time.</p>


                        </li>



                        <li>
                            <a name="SM_BinaryReader"></a><strong>Binary Reader and Binary Writer</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Quiz/MemoryManagement_FileHandling.htm">Quiz</a></li>
                            </ul>

                            <p>The BinaryReader class is used for reading strings and elementary data types, whereas the BinaryWriter class writes elementary types in binary data from a sequential text file. Both BinaryReader and BinaryWriter read and write information as binary rather than text. Both these classes are used to read and write primitive data types and strings. If you deal only with primitive types, this is the best stream to use.</p>
                            <table class="content-table">
                                <tr>
                                    <th>Data Type</th>
                                    <th>Binary Reader</th>
                                    <th>Binary Writer</th>
                                </tr>
                                <tr>
                                    <td>Buffer of bytes</td>
                                    <td>Read</td>
                                    <td>Write(byte[], int, int)</td>
                                </tr>
                                <tr>
                                    <td>Boolean</td>
                                    <td>ReadBoolean</td>
                                    <td>Write(bool)</td>
                                </tr>
                                <tr>
                                    <td>Byte</td>
                                    <td>ReadByte</td>
                                    <td>Write(byte)</td>
                                </tr>
                                <tr>
                                    <td>Byte array</td>
                                    <td>ReadBytes</td>
                                    <td>Write(byte[])</td>
                                </tr>
                                <tr>
                                    <td>Char</td>
                                    <td>ReadChar</td>
                                    <td>Write(char)</td>
                                </tr>
                                <tr>
                                    <td>Char array</td>
                                    <td>ReadChars</td>
                                    <td>Write(char[])</td>
                                </tr>
                                <tr>
                                    <td>Double</td>
                                    <td>ReadDouble</td>
                                    <td>Write(double)</td>
                                </tr>
                                <tr>
                                    <td>Int16</td>
                                    <td>ReadInt16</td>
                                    <td>Write(Int16)</td>
                                </tr>
                                <tr>
                                    <td>Int32</td>
                                    <td>ReadInt32</td>
                                    <td>Write(Int32)</td>
                                </tr>
                                <tr>
                                    <td>Int64</td>
                                    <td>ReadInt64</td>
                                    <td>Write(Int64)</td>
                                </tr>
                                <tr>
                                    <td>Single</td>
                                    <td>ReadSingle</td>
                                    <td>Write(single)</td>
                                </tr>
                                <tr>
                                    <td>String</td>
                                    <td>ReadString</td>
                                    <td>Write(string)</td>
                                </tr>

                            </table>

                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Console.WriteLine("Preparing to Write ...");
                //Open a FileStream on the file "MyProfile"
                FileStream fout = new FileStream(@"D:\MyProfile.txt", FileMode.OpenOrCreate,
                FileAccess.Write, FileShare.ReadWrite);
                //Create a BinaryWriter from the FileStream
                BinaryWriter bw = new BinaryWriter(fout);
                //Create some arbitrary variables
                string name = "Johnson";
                int age = 25;
                double height = 5.8;
                bool single = true;
                char gender = 'M';
                //Write the values to file
                bw.Write(name);
                bw.Write(age);
                bw.Write(height);
                bw.Write(single);
                bw.Write(gender);
                //Close the file and free resources
                bw.Close();
                Console.WriteLine("Profile Created...");
            }
            catch (IOException e)
            {
                Console.WriteLine("Something went wrong \n:" + e);
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>


                            <p>Sample application to read primitive types from an existing file using BinaryReader:</p>



                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Console.WriteLine("Preparing to Read ...");
                //Open a FileStream in Read mode
                FileStream fin = new FileStream(@"D:\MyProfile.txt", FileMode.Open,
                FileAccess.Read, FileShare.ReadWrite);
                //Create a BinaryReader from the FileStream
                BinaryReader br = new BinaryReader(fin);
                //Seek to the start of the file
                br.BaseStream.Seek(0, SeekOrigin.Begin);
                //Read from the file and store the values to the variables
                string name = br.ReadString();
                int age = br.ReadInt32();
                double height = br.ReadDouble();
                bool single = br.ReadBoolean();
                char gender = br.ReadChar();
                //Display the data on the console
                Console.WriteLine("Name         :" + name);
                Console.WriteLine("Age          :" + age);
                Console.WriteLine("Height       :" + height);
                Console.WriteLine("Single?      :" + single);
                Console.WriteLine("Gender (M/F) :" + gender);
                //Close the stream and free the resources
                br.Close();                
            }
            catch (IOException e)
            {
                Console.WriteLine("Something went wrong \n:" + e);
            }
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>







                        </li>
                    </ul> 
                    <p><a href="#top">Top of page</a></p>

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_Serialization"></a>
                    <h2>Serialization</h2>    
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_IntroductiontoSerialization"></a><strong>Introduction to Serialization</strong><br />
                            <br />
                            <p>Serialization is the process of converting an object into a stream of bytes in order to persist it to memory, a database, or a file. Its main purpose is to save the state of an object in order to be able to recreate it when needed. The reverse process is called deserialization.</p>
                            <p style="text-align:center">
                                <img src="Images/SM_IntroSerialization.jpg" />
                            </p>
                            <p>Run-time metadata knows about each object's layout in memory and its field and property definitions. Serializable objects can be converted into stream of bytes. This stream of bytes can be written to memory, file or database. These bytes can be read back to re-create the object. An object can be serialized in different formats including Binary or XML format</p>












                        </li>



                        <li>
                            <a name="SM_BinarySerialization"></a><strong>Binary Serialization</strong><br />
                            <br />
                            <ul class="horimenu anchorLinks">
                                <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_BinarySerialization">Demo</a></li>
                                <li class="last"><a href="../Exercises/AdvancedCSharpExercises.htm#E_BinarySerialization">Exercise</a></li>
                            </ul>
                            <p>A type is NOT Binary Serializable unless Type is specifically marked with Serializable attribute. The members marked with NonSerialized Attribute are not Serialized. A class cannot inherit the Serializable attribute from a base class; it must explicitly include the attribute. However, a derived class can be made Serializable only if base class is Serializable. In case of Binary serialization, all fields irrespective of the access modifier can be serialized.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    [Serializable]
    public class Employee
    {
        public int empId;
        public string name;
        [NonSerialized]
        public string address;
        private DateTime dateOfBirth;
        public Employee(int empId, string name, string address, DateTime dateOfBirth)
        {
            this.empId = empId;
            this.name = name;
            this.address = address;
            this.dateOfBirth = dateOfBirth;
        }
        public void PrintDetails()
        {
            Console.WriteLine("EmpId: {0}, EmpName: {1}, Address: {2}, DateOfBirth: {3}", 	empId, name, address, dateOfBirth);
        }
    }
    class Program
    {
      public static void Main()
      {
         BinaryFormatter binaryFormatter = new BinaryFormatter();
         FileStream fileStream;
         DateTime dateOfBirth = new DateTime(1982, 11, 23);
         Employee empObj1 = new Employee(1001, "Javier", "Detroit", dateOfBirth);
         fileStream = new FileStream(@"D:\Employee.bin", FileMode.Create, FileAccess.Write);
         binaryFormatter.Serialize(fileStream, empObj1);
         fileStream.Close();
         fileStream = new FileStream(@"D:\Employee.bin", FileMode.Open, FileAccess.Read);
         Employee empObj2 = (Employee)binaryFormatter.Deserialize(fileStream);
         fileStream.Close();
         empObj2.PrintDetails();
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>


                        </li>



                        <li>
                            <a name="SM_XMLSerialization"></a><strong>XML Serialization</strong><br />
                            <br />
                            <p>In XML serialization, all public types are Serializable by default. Only public members can be serialized in XML serialization. If a public member is not required to be serialized, it should be marked with System.Xml.Serialization.XmlIgnore attribute.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    public class Employee
    {
        public int empId;
        public string name;
        [XmlIgnore]
        public string address;
        private DateTime dateOfBirth;
        public Employee(){ }
        public Employee(int empId, string name, string address, DateTime dateOfBirth)
        {
            this.empId = empId;
            this.name = name;
            this.address = address;
            this.dateOfBirth = dateOfBirth;
        }
    public void PrintDetails()
    {
        Console.WriteLine("EmpId: {0}, EmpName: {1}, Address: {2}, DateOfBirth: 		{3}", empId, name, address, dateOfBirth);
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The class being used for serialization and deserialization should necessarily have a parameter-less constructor as it is used internally by serialization and deserialization classes.</p>
                            <p>
                                <div class="codesnippet">
                                    <div>
                                        <pre>    class Program
    {
        public static void Main()
        {
  
         XmlSerializer xmlSerializer = new XmlSerializer(typeof(Employee));  
     
         DateTime dateOfBirth = new DateTime(1982, 11, 23);
         Employee empObj1 = new Employee(1001, "Javier", "Detroit", dateOfBirth);
         StreamWriter streamWriter = new StreamWriter(@"D:\Employee.xml");
         xmlSerializer.Serialize(streamWriter, empObj1);
         streamWriter.Close();
         StreamReader streamReader = new StreamReader(@"D:\Employee.xml");
         Employee empObj2 = (Employee)xmlSerializer.Deserialize(streamReader);
         streamReader.Close();
         empObj2.PrintDetails();
        }
    }
</pre>
                                    </div>
                                </div>
                            </p>
                            <p>The XML file will appear like this:</p>
                            <p style="text-align:center">
                                <img src="Images/SM_XMLSerln.jpg" />
                            </p>

                        </li>
                    </ul> 
                    <p><a href="#top">Top of page</a></p>-->
                    <!--newly added-->
                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_AsynchronousProgramming"></a>
                    <h2>File Handling</h2>
                    <ul class="getStartedList">
                        <li>
                            <a name="SM_FileHandling"></a><strong>Introduction to Files and Streams</strong><br />
                            <br />
                            <p>
                                Files are unmanaged resources in .NET. When a file is opened for reading or writing, it becomes a stream. Stream is a sequence of bytes traveling from a source to a destination over a communication path. An input stream allows you to read data from a source file, and an output stream allows you to write data to a destination file.
                            </p>

                            <p style="text-align:center">
                                <img src="Images/FileHandling.jpg" />
                            </p>
                        </li>

                        <li>
                            Commonly used classes for file handling<br /><br />
                            <table class="content-table">
                                
                                <tr>
                                    <td>FileStream</td>
                                    <td>It can be used to create a stream from a file
</td>
                                </tr>
                                <tr>
                                    <td>BinaryReader</td>
                                    <td>It is used to read primitive data types from a stream
</td>
                                </tr>
                                <tr>
                                    <td>BinaryWriter</td>
                                    <td>It is used to write primitive data types to a stream
</td>
                                </tr>
                                <tr>
                                    <td>
                                        StreamReader
                                    </td>
                                    <td>
                                        It is used to read characters from a stream

                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        StreamWriter
                                    </td>
                                    <td>
                                        It is used to write characters to a stream.

                                    </td>
                                </tr>
                                <tr>
                                    <td>DirectoryInfo</td>
                                    <td>It is used to perform operations on directories
</td>
                                </tr>
                                <tr>
                                    <td>FileInfo</td>
                                    <td>It is used to perform operations on files
</td>
                                </tr>

                            </table>

                        </li>


                        <li>
                            Files can be accessed in following ways:<br /><br />
                            <table class="content-table">
                                <tr>
                                    <th>Member Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <td>Read</td>
                                    <td>Read access to the file. Data can be read from the file. Combine with Write for read/write access.</td>
                                </tr>
                                <tr>
                                    <td>ReadWrite</td>
                                    <td>Read and write access to the file. Data can be written to and read from the file.</td>
                                </tr>
                                <tr>
                                    <td>Write</td>
                                    <td>Write access to the file. Data can be written to the file. Combine with Read for read/write access.</td>
                                </tr>

                            </table>

                        </li>
                        <li>
                            Files can be used in various modes:<br />
                            <br />
                            <table class="content-table">
                                <tr>
                                    <th>Member name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <td>Append</td>
                                    <td>Opens the file if it exists and seeks to the end of the file, or creates a new file. This requires FileIOPermissionAccess.Append permission.FileMode.Append can be used only in conjunction with FileAccess.Write. Trying to seek to a position before the end of the file throws an IOException exception, and any attempt to read fails and throws a NotSupportedException exception.</td>
                                </tr>
                                <tr>
                                    <td>Create</td>
                                    <td>Specifies that the operating system should create a new file. If the file already exists, it will be overwritten. This requiresFileIOPermissionAccess.Write permission. FileMode.Create is equivalent to requesting that if the file does not exist, use CreateNew; otherwise, use Truncate. If the file already exists but is a hidden file, an UnauthorizedAccessException exception is thrown.</td>
                                </tr>
                                <tr>
                                    <td>CreateNew</td>
                                    <td>Specifies that the operating system should create a new file. This requires FileIOPermissionAccess.Write permission. If the file already exists, an IOException exception is thrown.</td>
                                </tr>
                                <tr>
                                    <td>Open</td>
                                    <td>Specifies that the operating system should open an existing file. The ability to open the file is dependent on the value specified by theFileAccess enumeration. A System.IO.FileNotFoundException exception is thrown if the file does not exist.</td>
                                </tr>
                                <tr>
                                    <td>OpenOrCreate</td>
                                    <td>Specifies that the operating system should open a file if it exists; otherwise, a new file should be created. If the file is opened withFileAccess.Read, FileIOPermissionAccess.Read permission is required. If the file access is FileAccess.Write, FileIOPermissionAccess.Writepermission is required. If the file is opened with FileAccess.ReadWrite, both FileIOPermissionAccess.Read andFileIOPermissionAccess.Write permissions are required.</td>
                                </tr>
                                <tr>
                                    <td>Truncate</td>
                                    <td>Specifies that the operating system should open an existing file. When the file is opened, it should be truncated so that its size is zero bytes. This requires FileIOPermissionAccess.Write permission. Attempts to read from a file opened with FileMode.Truncate cause anArgumentException exception.</td>
                                </tr>
                            </table>
                        </li>
                    </ul>

                    <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                    <a name="SM_Stream Writer and Stream Reader"></a>
                    <h2>Stream Writter and Stream Reader</h2>
                <p>StreamReader class provide methods can be used to Read text from a file</p>    
                <ul class="getStartedList">
                  
                    </ul>
                <div class="codesnippet">
<pre>
class Program
    {
    public static void Main()
    {
        fileStream = new FileStream(@"D:\CurrentDate.txt", FileMode.Open, FileAccess.Read);
        StreamReader streamReader = new StreamReader(fileStream);
        Console.WriteLine(streamReader.ReadToEnd());
        streamReader.Close();
        fileStream.Close();
    }
    }

</pre>
                </div>
                <br />
                    <p>  StreamWriter class provide methods can be used to Write text to in a file.</p>
                <div class="codesnippet">
 <pre>
    class Program
    {
    public static void Main()
    {
        FileStream fileStream;
        fileStream = new FileStream(@"D:\CurrentDate.txt",FileMode.Append, FileAccess.Write);
        StreamWriter streamWriter = new StreamWriter(fileStream);
        streamWriter.WriteLine(DateTime.Now);
        streamWriter.Close();
        fileStream.Close();
    }
    }

</pre>
                    <br />

                </div>
                <br />
                    <p>ReadToEnd() method of StreamReader reads the entire content of the file. StreamReader has other Read methods also. E.g. Read() reads one character at a time and ReadLine() reads one line at a time.</p>


                        <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                        <a name="SM_AsynchronousProgramming"></a>
                        <h2>Asynchronous Programming</h2>    <!--Main Heading-->
                        <ul class="getStartedList">
                            <li>
                                <a name="SM_IntroductiontoAsynchronousProgramming"></a><strong>Introduction to Asynchronous Programming</strong><br />
                                <br />
                                <p>Asynchronous Programming enhances the overall responsiveness and overcome performance bottlenecks of your application. Visual Studio 2013 introduces a simplified approach, async programming, that leverages asynchronous support in the .NET Framework 4.5 and the Windows Runtime. The compiler does the difficult work that the developer used to do, and your application retains a logical structure that resembles synchronous code. As a result, you get all the advantages of asynchronous programming with a fraction of the effort.</p>
                                <p>You can use the async feature to access files. By using the async feature, you can call into asynchronous methods without using callbacks or splitting your code across multiple methods or lambda expressions. To make synchronous code asynchronous, you just call an asynchronous method instead of a synchronous method and add a few keywords to the code.</p>

                            </li>



                            <li>
                                <a name="SM_async"></a><strong>async, await and Task keywords</strong><br />
                                <br />
                                <ul class="horimenu anchorLinks">
                                    <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_AsynchronousProgramming">Demo</a></li>
                                </ul>

                                <p>With the help of ‘async’ and ‘await’ keywords, one can use resources in the .NET Framework 4.5 and the Windows Runtime to create an asynchronous method. The ‘await’ keyword is applied to a task in an asynchronous method to suspend the execution of the method until the awaited task completes. During this time, the control is returned back to the caller of this asynchronous method. This approach proves especially valuable for applications that access the UI thread because all UI-related activity usually shares one thread. When you use asynchronous methods, the application continues to respond to the UI.</p>
                                <p>If you specify that a method is an async method by using an Async or async modifier, you enable the following two capabilities.</p>
                                <ul>
                                    <li>
                                        The marked async method can use Await or await to designate suspension points. The await operator tells the compiler that the async method can't continue past that point until the awaited asynchronous process is complete. In the meantime, control returns to the caller of the async method.
                                        <br />
                                        The suspension of an async method at an await expression doesn't constitute an exit from
                                        the method, and finally blocks don’t run.

                                    </li>

                                    <li>The marked async method can itself be awaited by methods that call it.</li>

                                </ul>
                                <p>In .NET Framework programming, an async method typically returns a Task or a Task&lt;TResult&gt;. Inside an async method, an await operator is applied to a task that's returned from a call to another async method.</p>
                                <ul>
                                    <li>You specify Task&lt;TResult&gt; as the return type if the method contains a return statement that specifies an operand of type TResult</li>
                                    <li>You use Task as the return type if the method has no return statement or has a return statement that doesn't return an operand</li>
                                </ul>
                                <p>Each returned task represents ongoing work. A task encapsulates information about the state of the asynchronous process and, eventually, either the final result from the process or the exception that the process raises if it doesn't succeed.</p>

                                <br />
                                <h4>Example:</h4>
                                <br />
                                <p>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    public async void ProcessWrite()
    {
        string filePath = @"Temp.txt";
        string text = "Hello World\r\n";
        await WriteTextAsync(filePath, text);
    }
    private async Task WriteTextAsync(string filePath, string text)
    {
        byte[] encodedText = Encoding.Unicode.GetBytes(text);
        using (FileStream sourceStream = new FileStream(filePath,
            FileMode.Append, FileAccess.Write, FileShare.None,
            bufferSize: 4096, useAsync: true))
        {
            await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
        };
    }
</pre>
                                        </div>
                                    </div>
                                </p>
                                <p>At each await statement, the method immediately exits. When the file I/O is complete, the method resumes at the statement that follows the await statement. Note that the async modifier is in the definition of methods that use the await statement.</p>



                            </li>



                        </ul> <!--Sub Heading-->
                        <p><a href="#top">Top of page</a></p>

                        <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                        <a name="SM_XML"></a>
                        <h2>XML</h2>    <!--Main Heading-->
                        <ul class="getStartedList">
                            <li>
                                <a name="SM_IntroductiontoXML"></a><strong>Introduction to XML</strong><br />
                                <br />
                                <ul class="horimenu anchorLinks">
                                    <li class="last"><a href="../Demos/AdvancedCSharpDemos.html#Demo_XML">Demo</a></li>
                                </ul>



                                <ul>
                                    <li>A typical XML document is made up of tags enclosing the data; tag names describe the data</li>
                                    <li>Because the language is extensible, you can create tags that are specific to your need</li>
                                    <li>
                                        For example, your document may contain tags to structure information about employees
                                        <ul>
                                            <li> The tags may include &lt;Name&gt;, &lt;Designation&gt; and &lt;Address&gt;  </li>
                                        </ul>
                                    </li>
                                    <li>
                                        Data stored in XML is self-descriptive
                                        <ul>
                                            <li>One can understand the data by just looking at tag names</li>
                                        </ul>
                                    </li>



                                </ul>
                                <p>Consider the following XML:</p>
                                <p>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    &lt;Employee&gt;
       &lt;Name&gt;John Smith&lt;/Name&gt;
       &lt;Designation&gt;Software Engineer&lt;/Designation&gt;
       &lt;Address&gt;Infosys, Bangalore&lt;/Address&gt;
    &lt;/Employee&gt;
</pre>
                                        </div>
                                    </div>
                                </p>
                                <p>In case your application needed to process based on a certain last name, you could restructure the &lt;name&gt; tag to facilitate this easily, by extending the tags and search based on the last name. This is the extensibility possible in XML.</p>
                                <p>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    &lt;Employee&gt;
       &lt;Name&gt;
             &lt;FirstName&gt;John&lt;/FirstName&gt;
             &lt;LastName&gt;Smith&lt;/LastName&gt;
       &lt;/Name&gt;
       &lt;Designation&gt;Software Engineer&lt;/Designation&gt;
       &lt;Address&gt;Infosys, Bangalore&lt;/Address&gt;
    &lt;/Employee&gt;
</pre>
                                        </div>
                                    </div>
                                </p>
                                <ul>
                                    <li>XML tags are not predefined.</li>
                                    <li>In XML all elements must have a closing tag.</li>
                                    <li>XML tags are case sensitive.  &lt;name&gt; is different from  &lt;Name&gt;.</li>
                                    <li>All XML elements can have attributes (optional).</li>
                                    <li>The attributes have to be in name/value pairs </li>
                                    <li>In XML, the attribute is not mandatory, but if there is any attribute, then the value must be enclosed in quotes. </li>
                                    <li>In XML, there should be a proper nesting of all elements and must have only one root element.</li>
                                    <li>All other elements must be enclosed within the root element.</li>

                                </ul>
                                <p>
                                    <div class="codesnippet">
                                        <div>
                                            <pre>    &lt;student&gt;
	    &lt;name&gt;Jack&lt;/name&gt;
	    &lt;age&gt;15&lt;/age&gt;
    &lt;/student&gt;
</pre>
                                        </div>
                                    </div>
                                </p>








                            </li>

                            <li>
                                <a name="SM_XMLSchema"></a><strong>XML Schema</strong><br />
                                <br />
                                <p>Well-formedness (syntactical correctness) is a minimum requirement of an XML document. Valid XML documents are semantically correct (according to your business rules). Validity checking is also done by a parser. To check if an XML document is valid, it must be validated. A document cannot be validated unless an XML schema is written. For the XML document to be valid, it must follow all the rules set forth in the Schema. </p>
                                <ul>
                                    <li>An XML document is valid if it has an associated XML Schema and if the document complies with the constraints expressed in it</li>
                                    <li>If an XML document is valid, it is also well-formed but not vice-versa</li>
                                </ul>











                            </li>

                            <li>
                                <a name="SM_XMLNamespace"></a><strong>XML Namespace</strong><br />
                                <br />
                                <ul class="horimenu anchorLinks">
                                    <li class="last"><a href="../Quiz/Serialization_XML.htm">Quiz</a></li>
                                </ul>
                                <p>Namespaces are used to resolve name conflicts. When 2 elements have the same name but actually do not refer the same element as per XML schema, the conflict can be resolved by using namespaces.</p>










                            </li>
                        </ul> <!--Sub Heading-->
                        <p><a href="#top">Top of page</a></p>


                        <div class="hr"><img src="../Images/hr-gradient-right-side.jpg" /></div>
                        <a name="RefMaterials"></a>
                        <h2>Other Reference Materials</h2>
                        <ul class="getStartedList">
                            <li>
                                <a name="Presentation"></a><strong>'201-001-Slides-AdvancedCSharpProgramming.pptx'</strong><br />
                                <p> Advanced CSharp presentation file is available under 'Reference Materials' folder</p>
                            </li>
                            <li>
                                <a name="CaseStudy"></a><strong>Case Study</strong><br />
                                <p>
                                    All the documents related to 'Quick Kart' case study is available under Reference Materials -> Supplied Files -> 'Case Study' folder
                                </p>
                            </li>
                            <li>
                                <a name="OtherRef"></a><strong>Other Materials</strong><br />
                                <p>
                                    All other neccessary files are provided under Reference Materials -> 'Supplied Files' folder
                                </p>
                            </li>
                        </ul>
                        <p><a href="#top">Top of page</a></p>
                    </ul></div>
               
                <div class="clearBoth">
                </div>
            </div>
        </div>
    </div>
  
    <div class="footer">
        <div class="csharpLink">
            <img alt="C Sharp" src="../Images/CSharp-footer.png" />
        </div>
        <div class="leftSideLinks">
            <span>C Sharp Learning Kit</span>
            &nbsp;&nbsp;&nbsp;
            &copy;&nbsp;2015 Infosys
        </div>
    </div>

    <dialog id="dialogImage" class="overlay">

        <dd style="text-align:center;vertical-align:middle;position: relative;top: 50%;-webkit-transform: translateY(-50%);-ms-transform: translateY(-50%);transform: translateY(-50%);">

            <div id="ImageViewer" style="text-align:center; vertical-align:middle">

            </div>

        </dd>
        <dd>
            <div>
                <button type="button" class="overlay-close" id="closeImg">Close</button>
            </div>
        </dd>


    </dialog>
    <script src="../Script/Image.js"></script>
    <div id="hidden">
        <div>
            <center>
                <h3 style="color:antiquewhite">Navigate by Topic</h3>
            </center>
            <ul>
                <li>
                    <a href="#SM_EnterpriseApp">Enterprise Application</a>
                </li>
                <li>
                    <a href="#SM_ExceptionHandling">Exception Handling</a>
                </li>                               
                <li>
                    <a href="#SM_Generics">Generics</a>
                </li>
                <li>
                    <a href="#SM_NonGenericCollections">Non-Generic Collections</a>
                </li>
                <li>
                    <a href="#SM_Collections">Generic Collections</a>
                </li>
                <li>
                    <a href="#SM_LangEnhancementsinC#3.0and4.0">Language Enhancements in C# 3.0 and C# 4.0</a>
                </li> 
                <li>
                    <a href="#SM_Delegates">Delegates</a>
                </li>
                <li>
                    <a href="#SM_LINQ">LINQ</a>
                </li>
                <li>
                    <a href="#SM_MemoryManagement">Memory Management</a>
                </li>
                <li>
                    <a href="#SM_FileHandling">File Handling</a>
                </li>
                <!--<li>
                    <a href="#SM_AsynchronousProgramming">Asynchronous Programming</a>
                </li>-->
                <!--<li>
                    <a href="#SM_Serialization">Serialization</a>
                </li>-->
                <li>
                    <a href="#SM_IntroductiontoAsynchronousProgramming">Asynchronous Programming</a>
                </li>
                <li>
                    <a href="#SM_XML">XML</a>
                </li>               
            </ul>
        </div>
    </div>
    <div class="back">
        <a href="../Index.htm" title="Go to TOC"> &laquo;</a>
    </div>

</body>
</html>
